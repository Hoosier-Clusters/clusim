
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>Installation &#8212; CluSim  documentation</title>
    <link rel="stylesheet" href="_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">CluSim  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Contents</h2>
    <div class="sidebar-localtoc">
      <ul>
<li><a class="reference internal" href="#">Installation</a></li>
<li><a class="reference internal" href="#examples-and-usage">Examples and Usage</a><ul>
<li><a class="reference internal" href="#a-first-comparison">A first comparison</a></li>
<li><a class="reference internal" href="#basics-of-element-centric-similarity">Basics of element-centric similarity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-clustering">The “Clustering”</a></li>
<li><a class="reference internal" href="#module-clusim.clugen">Clustering Generation</a></li>
<li><a class="reference internal" href="#clustering-similarity">Clustering Similarity</a><ul>
<li><a class="reference internal" href="#pairwise-counting-measures">Pairwise Counting Measures</a></li>
<li><a class="reference internal" href="#information-theoretic-measures">Information Theoretic Measures</a></li>
<li><a class="reference internal" href="#correction-for-chance">Correction for Chance</a></li>
<li><a class="reference internal" href="#overlapping-clustering-similarity">Overlapping Clustering Similarity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-clusim.clusimelement">Element-centric Clustering Similarity</a></li>
<li><a class="reference internal" href="#module-clusim.dag">DAG and Dendrogram</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>

    </div>
  </div>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/clusim.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="#">Docs</a></li>
              
              <li>Installation</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <p>Welcome to CluSim’s documentation!</p>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<p>This package (will be) available in PyPI. Just run the following command on terminal to install.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pip</span> <span class="n">install</span> <span class="n">clusim</span>
</pre></div>
</div>
<p>You can also source the code directly from the github [project page](<a class="reference external" href="https://github.com/Hoosier-Clusters/clusim">https://github.com/Hoosier-Clusters/clusim</a>).</p>
</div>
<div class="section" id="examples-and-usage">
<h1>Examples and Usage<a class="headerlink" href="#examples-and-usage" title="Permalink to this headline">¶</a></h1>
<div class="section" id="a-first-comparison">
<h2>A first comparison<a class="headerlink" href="#a-first-comparison" title="Permalink to this headline">¶</a></h2>
<p>We start by importing the required modules</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
</pre></div>
</div>
<p>The simplest way to make a Clustering is to use an elm2clu_dict which maps each element.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, the similarity of the two Clusterings can be found using the Jaccard Index.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">jaccard_index</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="basics-of-element-centric-similarity">
<h2>Basics of element-centric similarity<a class="headerlink" href="#basics-of-element-centric-similarity" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]})</span>
</pre></div>
</div>
<p>The basic element-centric similarity score with a fixed alpha:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">element_sim</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also get the element scores.  Note that since non-numberic elements are allowed, the element scores returns a dict which maps the elements to the index in the elementScore array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">elementScores</span><span class="p">,</span> <span class="n">relabeled_elements</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">element_sim_elscore</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-clustering">
<h1>The “Clustering”<a class="headerlink" href="#the-clustering" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="clusim.clustering.Clustering">
<em class="property">class </em><code class="descclassname">clusim.clustering.</code><code class="descname">Clustering</code><span class="sig-paren">(</span><em>elm2clu_dict=None</em>, <em>clu2elm_dict=None</em>, <em>hier_graph=None</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for clusterings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>elm2clu_dict</strong> (<em>dict</em>) – optional
Initialize based on an elm2clu_dict: { elementid: [clu1, clu2, … ] }.
The value is a list of clusters to which the element belongs.</li>
<li><strong>clu2elm_dict</strong> (<em>dict</em>) – optional
Initialize based on an clu2elm_dict: { clusid: [el1, el2, … ]}.
Each cluster is a key with value a list of elements which belong to it.</li>
<li><strong>hier_graph</strong> (<em>networkx.Graph</em><em>(</em><em>)</em>) – optional
Initialize based on a hierarchical acyclic graph capturing the cluster
membership at each scale.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="clusim.clustering.Clustering.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the clustering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">deep copy of the clustering</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">clusim</span><span class="o">.</span><span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu2</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.from_elm2clu_dict">
<code class="descname">from_elm2clu_dict</code><span class="sig-paren">(</span><em>elm2clu_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.from_elm2clu_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates a clustering from an elm2clu_dict dictionary:
{ elementid: [clu1, clu2, … ] } where each element is a key with
value a list of clusters to which it belongs.  Clustering features
are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>elm2clu_dict</strong> (<em>dict</em>) – { elementid: [clu1, clu2, … ] }</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_elm2clu_dict</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.from_clu2elm_dict">
<code class="descname">from_clu2elm_dict</code><span class="sig-paren">(</span><em>clu2elm_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.from_clu2elm_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates a clustering from an clu2elm_dict dictionary:
{ clusid: [el1, el22, … ] } where each cluster is a key with
value a list of elements which belong to it.  Clustering features
are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>clu2elm_dict</strong> (<em>dict</em>) – { clusid: [el1, el2, … ] }</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu2elm_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_clu2elm_dict</span><span class="p">(</span><span class="n">clu2elm_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.from_cluster_list">
<code class="descname">from_cluster_list</code><span class="sig-paren">(</span><em>cluster_list</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.from_cluster_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates a clustering from a cluster list:
[ [el1, el2, …], [el5, …], … ],  a list of lists,
where each inner list corresponds to the elements in
a cluster.  Clustering features are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cluster_list</strong> (<em>list</em>) – list of lists
[ [el1, el2, …], [el5, …], … ]</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cluster_list</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_cluster_list</span><span class="p">(</span><span class="n">cluster_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.to_cluster_list">
<code class="descname">to_cluster_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.to_cluster_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns a clustering in cluster list format:
[ [el1, el2, …], [el5, …], … ],  a list of lists,
where each inner list corresponds to the elements in
a cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">cluster_list : list of lists, [ [el1, el2, …], [el5, …], … ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.from_membership_list">
<code class="descname">from_membership_list</code><span class="sig-paren">(</span><em>membership_list</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.from_membership_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates a clustering from a membership list:
[ clu_for_el1, clu_for_el2, … ],  a list of cluster names where
the ith entry corresponds to the cluster membership of the ith element.
Clustering features are then calculated.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Membership Lists can only represent partitions (no overlaps)</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>membership_list</strong> (<em>list</em>) – list of cluster names
clu_for_el1, clu_for_el2, … ]</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">membership_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_membership_list</span><span class="p">(</span><span class="n">membership_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.to_membership_list">
<code class="descname">to_membership_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.to_membership_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the clustering as a membership list:
[ clu_for_el1, clu_for_el2, … ],  a list of cluster names
the ith entry corresponds to the cluster membership of the ith element.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Membership Lists can only represent partitions (no overlaps)</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of element memberships, [ clu_for_el1, clu_for_el2, … ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.clustering_from_igraph_cover">
<code class="descname">clustering_from_igraph_cover</code><span class="sig-paren">(</span><em>igraphcover</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.clustering_from_igraph_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates a clustering from an igraph VertexCover object.
See the <code class="xref py py-class docutils literal notranslate"><span class="pre">igraph.Cover.VertexCover</span></code> class.
Clustering features are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>igraphcover</strong> (<em>igraph.Cover.VertexCover</em>) – the igraph VertexCover</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.to_clu2elm_dict">
<code class="descname">to_clu2elm_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.to_clu2elm_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a clu2elm_dict: {clusterid: [el1, el2, … ]} from the
stored elm2clu_dict.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.to_elm2clu_dict">
<code class="descname">to_elm2clu_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.to_elm2clu_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a elm2clu_dict: {elementid: [clu1, clu2, … ]} from the
stored clu2elm_dict.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.find_clu_size_seq">
<code class="descname">find_clu_size_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.find_clu_size_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>This method finds the cluster size sequence for the clustering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of integers
A list where the ith entry corresponds to the size of the ith
cluster.</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster Size Sequence:&quot;</span><span class="p">,</span> <span class="n">clu</span><span class="o">.</span><span class="n">find_clu_size_seq</span><span class="p">())</span>
<span class="go">* Cluster Size Sequence: [3, 2, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.find_num_overlap">
<code class="descname">find_num_overlap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.find_num_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>This method finds the number of elements which are in more than one
cluster in the clustering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The number of elements in at least two clusters.</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Overlap size:&quot;</span><span class="p">,</span> <span class="n">clu</span><span class="o">.</span><span class="n">find_num_overlap</span><span class="p">())</span>
<span class="go">* Overlap size: 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.merge_clusters">
<code class="descname">merge_clusters</code><span class="sig-paren">(</span><em>c1</em>, <em>c2</em>, <em>new_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.merge_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>This method merges the elements in two clusters from the clustering.
The merged clustering will be named new_name if provided, otherwise
it will assume the name of cluster c1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">merge_clusters</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">new_name</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.downstream_elements">
<code class="descname">downstream_elements</code><span class="sig-paren">(</span><em>cluster</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.downstream_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>This method finds all elements contained in a cluster from a
hierarchical clustering by visiting all downstream clusters
and adding their elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cluster</strong> – the name of the parent cluster</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">element list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="clusim.clustering.Clustering.from_scipy_linkage">
<code class="descname">from_scipy_linkage</code><span class="sig-paren">(</span><em>linkage_matrix</em>, <em>dist_rescaled=False</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.Clustering.from_scipy_linkage" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates a clustering from a scipy linkage object resulting
from the agglomerative hierarchical clustering.
Clustering features are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>linkage_matrix</strong> (<em>numpy.matrix</em>) – the linkage matrix from scipy</li>
<li><strong>dist_rescaled</strong> (<em>Boolean</em>) – (default False)
if True, the linkage distances are linearlly rescaled to be
in-between 0 and 1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="k">import</span> <span class="n">dendrogram</span><span class="p">,</span> <span class="n">linkage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="go">                                          size=[100,])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="go">                                          size=[50,])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">),</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s1">&#39;ward&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_scipy_linkage</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">dist_rescaled</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="clusim.clustering.ClusterError">
<em class="property">class </em><code class="descclassname">clusim.clustering.</code><code class="descname">ClusterError</code><span class="sig-paren">(</span><em>expression</em>, <em>message</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.ClusterError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-clusim.clustering"></span><span class="target" id="module-clustering"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">clusim.clustering.</code><code class="descname">Clustering</code><span class="sig-paren">(</span><em>elm2clu_dict=None</em>, <em>clu2elm_dict=None</em>, <em>hier_graph=None</em><span class="sig-paren">)</span></dt>
<dd><p>Base class for clusterings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>elm2clu_dict</strong> (<em>dict</em>) – optional
Initialize based on an elm2clu_dict: { elementid: [clu1, clu2, … ] }.
The value is a list of clusters to which the element belongs.</li>
<li><strong>clu2elm_dict</strong> (<em>dict</em>) – optional
Initialize based on an clu2elm_dict: { clusid: [el1, el2, … ]}.
Each cluster is a key with value a list of elements which belong to it.</li>
<li><strong>hier_graph</strong> (<em>networkx.Graph</em><em>(</em><em>)</em>) – optional
Initialize based on a hierarchical acyclic graph capturing the cluster
membership at each scale.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt>
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return a deep copy of the clustering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">deep copy of the clustering</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">clusim</span><span class="o">.</span><span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu2</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">from_elm2clu_dict</code><span class="sig-paren">(</span><em>elm2clu_dict</em><span class="sig-paren">)</span></dt>
<dd><p>This method creates a clustering from an elm2clu_dict dictionary:
{ elementid: [clu1, clu2, … ] } where each element is a key with
value a list of clusters to which it belongs.  Clustering features
are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>elm2clu_dict</strong> (<em>dict</em>) – { elementid: [clu1, clu2, … ] }</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_elm2clu_dict</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">from_clu2elm_dict</code><span class="sig-paren">(</span><em>clu2elm_dict</em><span class="sig-paren">)</span></dt>
<dd><p>This method creates a clustering from an clu2elm_dict dictionary:
{ clusid: [el1, el22, … ] } where each cluster is a key with
value a list of elements which belong to it.  Clustering features
are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>clu2elm_dict</strong> (<em>dict</em>) – { clusid: [el1, el2, … ] }</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu2elm_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_clu2elm_dict</span><span class="p">(</span><span class="n">clu2elm_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">from_cluster_list</code><span class="sig-paren">(</span><em>cluster_list</em><span class="sig-paren">)</span></dt>
<dd><p>This method creates a clustering from a cluster list:
[ [el1, el2, …], [el5, …], … ],  a list of lists,
where each inner list corresponds to the elements in
a cluster.  Clustering features are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cluster_list</strong> (<em>list</em>) – list of lists
[ [el1, el2, …], [el5, …], … ]</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cluster_list</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_cluster_list</span><span class="p">(</span><span class="n">cluster_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">to_cluster_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>This method returns a clustering in cluster list format:
[ [el1, el2, …], [el5, …], … ],  a list of lists,
where each inner list corresponds to the elements in
a cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">cluster_list : list of lists, [ [el1, el2, …], [el5, …], … ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">from_membership_list</code><span class="sig-paren">(</span><em>membership_list</em><span class="sig-paren">)</span></dt>
<dd><p>This method creates a clustering from a membership list:
[ clu_for_el1, clu_for_el2, … ],  a list of cluster names where
the ith entry corresponds to the cluster membership of the ith element.
Clustering features are then calculated.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Membership Lists can only represent partitions (no overlaps)</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>membership_list</strong> (<em>list</em>) – list of cluster names
clu_for_el1, clu_for_el2, … ]</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">membership_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_membership_list</span><span class="p">(</span><span class="n">membership_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">to_membership_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>This method returns the clustering as a membership list:
[ clu_for_el1, clu_for_el2, … ],  a list of cluster names
the ith entry corresponds to the cluster membership of the ith element.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Membership Lists can only represent partitions (no overlaps)</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of element memberships, [ clu_for_el1, clu_for_el2, … ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">clustering_from_igraph_cover</code><span class="sig-paren">(</span><em>igraphcover</em><span class="sig-paren">)</span></dt>
<dd><p>This method creates a clustering from an igraph VertexCover object.
See the <code class="xref py py-class docutils literal notranslate"><span class="pre">igraph.Cover.VertexCover</span></code> class.
Clustering features are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>igraphcover</strong> (<em>igraph.Cover.VertexCover</em>) – the igraph VertexCover</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">to_clu2elm_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Create a clu2elm_dict: {clusterid: [el1, el2, … ]} from the
stored elm2clu_dict.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">to_elm2clu_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Create a elm2clu_dict: {elementid: [clu1, clu2, … ]} from the
stored clu2elm_dict.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">find_clu_size_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>This method finds the cluster size sequence for the clustering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of integers
A list where the ith entry corresponds to the size of the ith
cluster.</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster Size Sequence:&quot;</span><span class="p">,</span> <span class="n">clu</span><span class="o">.</span><span class="n">find_clu_size_seq</span><span class="p">())</span>
<span class="go">* Cluster Size Sequence: [3, 2, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">find_num_overlap</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>This method finds the number of elements which are in more than one
cluster in the clustering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The number of elements in at least two clusters.</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Overlap size:&quot;</span><span class="p">,</span> <span class="n">clu</span><span class="o">.</span><span class="n">find_num_overlap</span><span class="p">())</span>
<span class="go">* Overlap size: 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">merge_clusters</code><span class="sig-paren">(</span><em>c1</em>, <em>c2</em>, <em>new_name=None</em><span class="sig-paren">)</span></dt>
<dd><p>This method merges the elements in two clusters from the clustering.
The merged clustering will be named new_name if provided, otherwise
it will assume the name of cluster c1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">merge_clusters</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">new_name</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">downstream_elements</code><span class="sig-paren">(</span><em>cluster</em><span class="sig-paren">)</span></dt>
<dd><p>This method finds all elements contained in a cluster from a
hierarchical clustering by visiting all downstream clusters
and adding their elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cluster</strong> – the name of the parent cluster</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">element list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">from_scipy_linkage</code><span class="sig-paren">(</span><em>linkage_matrix</em>, <em>dist_rescaled=False</em><span class="sig-paren">)</span></dt>
<dd><p>This method creates a clustering from a scipy linkage object resulting
from the agglomerative hierarchical clustering.
Clustering features are then calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>linkage_matrix</strong> (<em>numpy.matrix</em>) – the linkage matrix from scipy</li>
<li><strong>dist_rescaled</strong> (<em>Boolean</em>) – (default False)
if True, the linkage distances are linearlly rescaled to be
in-between 0 and 1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span><span class="p">,</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="k">import</span> <span class="n">dendrogram</span><span class="p">,</span> <span class="n">linkage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="go">                                          size=[100,])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="go">                                          size=[50,])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">),</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s1">&#39;ward&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span><span class="o">.</span><span class="n">from_scipy_linkage</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">dist_rescaled</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt>
<em class="property">exception </em><code class="descclassname">clusim.clustering.</code><code class="descname">ClusterError</code><span class="sig-paren">(</span><em>expression</em>, <em>message</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="function">
<dt id="clusim.clustering.print_clustering">
<code class="descclassname">clusim.clustering.</code><code class="descname">print_clustering</code><span class="sig-paren">(</span><em>clustering</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clustering.print_clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to print a clustering. Clusters are seperated by ‘|’. The fuction
will only print the leaf layer of a Hierarchical Clustering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>clustering</strong> (<em>Clsutering</em>) – The clustering to print</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_equal_clustering</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-clusim.clugen">
<span id="clustering-generation"></span><h1>Clustering Generation<a class="headerlink" href="#module-clusim.clugen" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-clugen"></span><dl class="function">
<dt id="clusim.clugen.make_equal_clustering">
<code class="descclassname">clusim.clugen.</code><code class="descname">make_equal_clustering</code><span class="sig-paren">(</span><em>n_elements</em>, <em>n_clusters</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clugen.make_equal_clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a random clustering with equally sized clusters.
If n_elements % n_clusters != 0, cluster sizes will differ by one
element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n_elements</strong> (<em>int</em>) – The number of elements</li>
<li><strong>n_clusters</strong> (<em>int</em>) – The number of clusters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The new clustering with equally sized clusters.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_equal_clustering</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clugen.make_random_clustering">
<code class="descclassname">clusim.clugen.</code><code class="descname">make_random_clustering</code><span class="sig-paren">(</span><em>n_elements=1, n_clusters=1, clu_size_seq=[1, 2], random_model='all', tol=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clugen.make_random_clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a random clustering according to one of three
random models. It is a wrapper around the specific functions for each random model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n_elements</strong> (<em>int</em>) – The number of elements</li>
<li><strong>n_clusters</strong> (<em>int</em>) – The number of clusters</li>
<li><strong>random_mode</strong> (<em>str</em>) – <p>The random model to use:</p>
<dl class="docutils">
<dt>’all’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements</dd>
<dt>’num’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements in n_clusters</dd>
</dl>
<p>’perm’ : the Permutaiton Model</p>
</li>
<li><strong>tol</strong> (<em>float</em>) – optional
The tolerance used by the algorithm for ‘all’ clusterings</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The new clustering.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="go">                                 random_model = &#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clugen.make_singleton_clustering">
<code class="descclassname">clusim.clugen.</code><code class="descname">make_singleton_clustering</code><span class="sig-paren">(</span><em>n_elements</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clugen.make_singleton_clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a clustering with each element in its own
cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n_elements</strong> (<em>int</em>) – The number of elements</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The new clustering.</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">import</span> <span class="n">clusim</span><span class="o">.</span><span class="n">clugen</span> <span class="k">as</span> <span class="n">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_singleton_clustering</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">=</span> <span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clugen.make_random_dendrogram">
<code class="descclassname">clusim.clugen.</code><code class="descname">make_random_dendrogram</code><span class="sig-paren">(</span><em>n_elements</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clugen.make_random_dendrogram" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a random Hierarchical Clustering.</p>
<p>:param int n_elements The number of elements</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The new clustering.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="clusim.clugen.shuffle_memberships">
<code class="descclassname">clusim.clugen.</code><code class="descname">shuffle_memberships</code><span class="sig-paren">(</span><em>clustering</em>, <em>percent=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clugen.shuffle_memberships" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a new clustering by shuffling the element
memberships from the original clustering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The original clustering.</li>
<li><strong>percent</strong> (<em>float</em>) – optional (default 1.0)
The fractional percentage (between 0.0 and 1.0) of the elements to
shuffle.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The new clustering.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orig_clu</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="go">                                      random_model = &#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">orig_clu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shuffle_clu</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">shuffle_memberships</span><span class="p">(</span><span class="n">orig_clu</span><span class="p">,</span> <span class="n">percent</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">shuffle_clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clugen.shuffle_memberships_pa">
<code class="descclassname">clusim.clugen.</code><code class="descname">shuffle_memberships_pa</code><span class="sig-paren">(</span><em>clustering</em>, <em>n_steps=1</em>, <em>constant_num_clusters=True</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clugen.shuffle_memberships_pa" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a new clustering by shuffling the element
memberships from the original clustering according to the preferential
attachment model.</p>
<p>See <a class="reference internal" href="#gates2017impact" id="id1">[GA17]</a> for a detailed explaination of the preferential
attachment model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The original clustering.</li>
<li><strong>n_steps</strong> (<em>int</em>) – optional (default 1)
The number of times to run the preferential attachment algorithm.</li>
<li><strong>constant_num_clusters</strong> (<em>Boolean</em>) – optional (default True)
Reject a shuffling move if it leaves a cluster with no elements.
Set to True to keep the number of clusters constant.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The new clustering with shuffled memberships.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orig_clu</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                      random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">orig_clu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shuffle_clu</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">shuffle_memberships_pa</span><span class="p">(</span><span class="n">orig_clu</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="go">                                         constant_num_clusters=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">shuffle_clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clugen.generate_random_partition_all">
<code class="descclassname">clusim.clugen.</code><code class="descname">generate_random_partition_all</code><span class="sig-paren">(</span><em>n_elements</em>, <em>tol=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clugen.generate_random_partition_all" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a random clustering according to the ‘All’
random model by uniformly selecting a clustering from the ensemble of all
clusterings with n_elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n_elements</strong> (<em>int</em>) – The number of elements</li>
<li><strong>tol</strong> (<em>float</em>) – (optional)
The tolerance used by the algorithm to approximate the probability distrubtion</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The randomly genderated clustering.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clu</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">generate_random_partition_all</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">=</span> <span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clugen.enumerate_random_partition_num">
<code class="descclassname">clusim.clugen.</code><code class="descname">enumerate_random_partition_num</code><span class="sig-paren">(</span><em>n_elements</em>, <em>n_clusters</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clugen.enumerate_random_partition_num" title="Permalink to this definition">¶</a></dt>
<dd><p>A generator for every partition in ‘Num’, the ensemble of all clusterings
with n_elements grouped into n_clusters, non-empty clusters.</p>
<p>Based on the solution provided by Adeel Zafar Soomro: <a class="reference external" href="http://codereview.stackexchange.com/questions/1526/finding-all-k-subset-partitions">a link</a>.</p>
<p>which was itself based on the algorithm from Knuth:
(Algorithm U) is described by Knuth in the Art of Computer Programming,
Volume 4, Fascicle 3B</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n_elements</strong> (<em>int</em>) – The number of elements</li>
<li><strong>n_clusters</strong> (<em>int</em>) – The number of clusters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The new clustering as a cluster list.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">clu</span> <span class="ow">in</span> <span class="n">clugen</span><span class="o">.</span><span class="n">clustering_ensemble_generator_num</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">print_clustering</span><span class="p">(</span><span class="n">clu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="clustering-similarity">
<h1>Clustering Similarity<a class="headerlink" href="#clustering-similarity" title="Permalink to this headline">¶</a></h1>
<p>The different clustering similarity measures available.</p>
<div class="section" id="pairwise-counting-measures">
<h2>Pairwise Counting Measures<a class="headerlink" href="#pairwise-counting-measures" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="clusim.sim.contingency_table">
<code class="descclassname">clusim.sim.</code><code class="descname">contingency_table</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.contingency_table" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the contigency table between two clusterings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The clustering1.n_clusters by clustering2.n_clusters contigency table as a list of lists</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                         random_model = &#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                         random_model = &#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cont_table</span> <span class="o">=</span> <span class="n">contingency_table</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cont_table</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.count_pairwise_cooccurence">
<code class="descclassname">clusim.sim.</code><code class="descname">count_pairwise_cooccurence</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.count_pairwise_cooccurence" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds the pairwise cooccurence counts between two
clusterings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>N11 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of element pairs assigned to the same clusters in both
clusterings</p>
</dd>
<dt>N10 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of element pairs assigned to the same clusters in
clustering1, but different clusters in clustering2</p>
</dd>
<dt>N01 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of element pairs assigned to different clusters in
clustering1, but the same clusters in clustering2</p>
</dd>
<dt>N00 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of element pairs assigned to different clusters in both
clusterings</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">print_clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                         random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                         random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N11</span><span class="p">,</span> <span class="n">N10</span><span class="p">,</span> <span class="n">N01</span><span class="p">,</span> <span class="n">N00</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">count_pairwise_cooccurence</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span>
<span class="go">                                                    clustering2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clustering1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_clustering</span><span class="p">(</span><span class="n">clustering2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">N11</span><span class="p">,</span>
<span class="go">        &quot;element pairs assigned to the same clusters in both clusterings&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">N10</span><span class="p">,</span>
<span class="go">        &quot;element pairs assigned to the same clusters in clustering1, but &quot;</span>
<span class="go">        &quot;different clusters in clustering2&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">N01</span><span class="p">,</span> <span class="s2">&quot;element pairs assigned to different clusters in &quot;</span>
<span class="go">               &quot;clustering1, but the same clusters in clustering2&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">N00</span><span class="p">,</span> <span class="s2">&quot;element pairs assigned to different clusters in both &quot;</span>
<span class="go">               &quot;clusterings&quot;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.jaccard_index">
<code class="descclassname">clusim.sim.</code><code class="descname">jaccard_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.jaccard_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Jaccard index between two clusterings <a class="reference internal" href="#jaccard1912flora" id="id2">[Jac12]</a>.</p>
<p>J = N11/(N11+N10+N01)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Jaccard index (between 0.0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">..</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
<span class="go">                                                n_clusters=3,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
<span class="go">                                                n_clusters=3,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">jaccard_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.rand_index">
<code class="descclassname">clusim.sim.</code><code class="descname">rand_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.rand_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Rand index between two clusterings <a class="reference internal" href="#rand1971randindex" id="id3">[Ran71]</a>.</p>
<p>RI = (N11 + N00) / (N11 + N10 + N01 + N00)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Rand index (between 0.0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">..</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">rand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.fowlkes_mallows_index">
<code class="descclassname">clusim.sim.</code><code class="descname">fowlkes_mallows_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.fowlkes_mallows_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Fowlkes and Mallows index between two
clusterings <a class="reference internal" href="#fowlkes1983hierarchicalcompare" id="id4">[FM83]</a>.</p>
<p>FM = N11 / sqrt( (N11 + N10) * (N11 + N01) )</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Fowlkes and Mallows index (between 0.0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">fowlkes_mallows_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.fmeasure">
<code class="descclassname">clusim.sim.</code><code class="descname">fmeasure</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.fmeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the F-measure between two clusterings.</p>
<p>Also known as:
Czekanowski index
Dice Symmetric index
Sorensen index</p>
<p>F = 2*N11 / (2*N11 + N10 + N01)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The F-measure (between 0.0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">fmeasure</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.purity_index">
<code class="descclassname">clusim.sim.</code><code class="descname">purity_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.purity_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Purity index between two clusterings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Purity index (between 0.0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">purity_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.classification_error">
<code class="descclassname">clusim.sim.</code><code class="descname">classification_error</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.classification_error" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Jaccard index between two clusterings.</p>
<p>CE = 1 - PI</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Classification Error (between 0.0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">CE is a distance measure, it is 0 for identical clusterings</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">classification_error</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.czekanowski_index">
<code class="descclassname">clusim.sim.</code><code class="descname">czekanowski_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.czekanowski_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Czekanowski index between two clusterings.</p>
<p>See Fmeasure</p>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.dice_index">
<code class="descclassname">clusim.sim.</code><code class="descname">dice_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.dice_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Dice index between two clusterings.</p>
<p>See Fmeasure</p>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.sorensen_index">
<code class="descclassname">clusim.sim.</code><code class="descname">sorensen_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.sorensen_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Sorensen index between two clusterings.</p>
<p>See Fmeasure</p>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.rogers_tanimoto_index">
<code class="descclassname">clusim.sim.</code><code class="descname">rogers_tanimoto_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.rogers_tanimoto_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Rogers and Tanimoto index between two
clusterings.</p>
<p>RT = (N11 + N00)/(N11 + 2*(N10+N01) + N00)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Rogers and Tanimoto index (between 0.0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">rogers_tanimoto_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.southwood_index">
<code class="descclassname">clusim.sim.</code><code class="descname">southwood_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.southwood_index" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the southwood index</p>
<p>N11 / (N10 + N01)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Southwood index (between 0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">southwood_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.pearson_correlation">
<code class="descclassname">clusim.sim.</code><code class="descname">pearson_correlation</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.pearson_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Pearson Correlation between two clusterings.</p>
<p>PC = (N11*N00 - N01*N10) / ((N11+N10) * (N11+N01) * (N00+N10) * (N00+N01))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Pearson Correlation (between -1.0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">pearson_correlation</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="information-theoretic-measures">
<h2>Information Theoretic Measures<a class="headerlink" href="#information-theoretic-measures" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="clusim.sim.nmi">
<code class="descclassname">clusim.sim.</code><code class="descname">nmi</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em>, <em>norm_type='sum'</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.nmi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Normalized Mutual Information (NMI)
between two clusterings <a class="reference internal" href="#danon2005comparingcomm" id="id5">[DDiazGDA05]</a>.</p>
<p>NMI = (S(c1) + S(c2) - S(c1, c2)) / norm(c1, c2)</p>
<p>where S(c1) is the Shannon Entropy of the clustering size distrubtion,
S(c1, c2) is the Shannon Entropy of the join clustering size distrubtion,
and norm(c1,c2) is a normalizetion term.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
<li><strong>norm_type</strong> (<em>str</em>) – ‘sum’ (default), ‘max’, ‘min’, ‘sqrt’, ‘none’
The normalization type:
‘sum’ uses the average of the two clustering entropies,
‘max’ uses the maximum of the two clustering entropies,
‘min’ uses the minimum of the two clustering entropies,
‘sqrt’ uses the geometric mean of the two clustering entropies,
‘none’ returns the Mutual Information without a normalization</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Normalized Mutual Information index (between 0.0 and inf)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">nmi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">nmi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">nmi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">nmi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;sqrt&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.vi">
<code class="descclassname">clusim.sim.</code><code class="descname">vi</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em>, <em>norm_type='none'</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.vi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the Variation of Information (VI)
between two clusterings <a class="reference internal" href="#meila2003comparingvi" id="id6">[Mei03]</a>.</p>
<p>VI is technically a distance measure and can assume values in the range
[0, inf), where 0 denotes identical clusterings.</p>
<p>VI = 2*S(c1, c2) - S(c1) - S(c2)</p>
<p>where S(c1) is the Shannon Entropy of the clustering size distrubtion, and
S(c1, c2) is the Shannon Entropy of the join clustering size distrubtion.</p>
<p>The VI can be transformed into a clustering similarity measure via the appropraite normalization.</p>
<p>VI_{sim} = 1 - 0.5*((S(c1,c2) - S(c1))/S(c2) + (S(c1,c2) - S(c2))/S(c1))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>norm_type <span class="classifier-delimiter">:</span> <span class="classifier">‘none’ (default) or ‘entropy’</span></dt>
<dd>The normalization type.  ‘none’ returns the stanard VI as a distance metric,
‘entropy’ retuns the normalized VI as a similarity measure</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The Variation of Information index (between 0.0 and inf)</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;num&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">vi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="correction-for-chance">
<h2>Correction for Chance<a class="headerlink" href="#correction-for-chance" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="clusim.sim.corrected_chance">
<code class="descclassname">clusim.sim.</code><code class="descname">corrected_chance</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em>, <em>measure='jaccard_index'</em>, <em>random_model='perm'</em>, <em>norm_type='sum'</em>, <em>n_samples=100</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.corrected_chance" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the adjusted Similarity for one of six random
models.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Clustering 2 is considered the gold-standard clustering for one-sided expectations</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
<li><strong>measure</strong> (<em>str</em>) – The similarity measure to evalute. Must be one of the
available_similarity_measures.</li>
<li><strong>random_model</strong> (<em>str</em>) – <p>The random model to use:</p>
<dl class="docutils">
<dt>’all’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements</dd>
<dt>’all1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements</dd>
<dt>’num’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements in n_clusters</dd>
<dt>’num1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements in n_clusters</dd>
</dl>
<p>’perm’ : the permutation model for a fixed cluster size sequence</p>
<dl class="docutils">
<dt>’perm1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the permutation model for a fixed</span></dt>
<dd>cluster size sequence, same as ‘perm’</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>n_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of random Clusterings sampled to determine the expected
similarity.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The adjusted Similarity measure</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;all&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;all&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">corrected_chance</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span>
<span class="go">                                  random_model=&#39;all&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">corrected_chance</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span>
<span class="go">                                  random_model=&#39;all1&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">corrected_chance</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span>
<span class="go">                                  random_model=&#39;num&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">corrected_chance</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span>
<span class="go">                                  random_model=&#39;num1&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">corrected_chance</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span>
<span class="go">                                  random_model=&#39;perm&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">corrected_chance</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span>
<span class="go">                                  random_model=&#39;perm1&#39;))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.sample_expected_sim">
<code class="descclassname">clusim.sim.</code><code class="descname">sample_expected_sim</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em>, <em>measure='jaccard_index'</em>, <em>random_model='perm'</em>, <em>n_samples=1</em>, <em>keep_samples=False</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.sample_expected_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the expected Similarity for all pair-wise
comparisons between Clusterings drawn from one of six random models.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Clustering 2 is considered the gold-standard clustering for one-sided expectations</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
<li><strong>measure</strong> (<em>str</em>) – The similarity measure to evalute. Must be one of the measures listed in
sim.available_similarity_measures.</li>
<li><strong>random_model</strong> (<em>string</em>) – <p>The random model to use:</p>
<dl class="docutils">
<dt>’all’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements</dd>
<dt>’all1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements</dd>
<dt>’num’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements in n_clusters</dd>
<dt>’num1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements in n_clusters</dd>
</dl>
<p>’perm’ : the permutation model for a fixed cluster size sequence</p>
<dl class="docutils">
<dt>’perm1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the permutation model for a fixed</span></dt>
<dd>cluster size sequence, same as ‘perm’</dd>
</dl>
</li>
<li><strong>n_samples</strong> (<em>int</em>) – The number of random Clusterings sampled to determine the expected
similarity.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The expected Similarity measure for all pair-wise comparisons under a
random model</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">sample_expected_sim</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">sample_expected_sim</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all1&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">sample_expected_sim</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">sample_expected_sim</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num1&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">sample_expected_sim</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">sample_expected_sim</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm1&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.expected_rand_index">
<code class="descclassname">clusim.sim.</code><code class="descname">expected_rand_index</code><span class="sig-paren">(</span><em>n_elements</em>, <em>random_model='num'</em>, <em>n_clusters1=2</em>, <em>n_clusters2=2</em>, <em>clu_size_seq1=None</em>, <em>clu_size_seq2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.expected_rand_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the expectation of the Rand index between all
pairs of clusterings drawn from one of six random models.</p>
<p>See <a class="reference internal" href="#hubert1985adjrand" id="id7">[HA85]</a> and <a class="reference internal" href="#gates2017impact" id="id8">[GA17]</a> for a detailed derivation and explaination of the different
random models.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Clustering 2 is considered the gold-standard clustering for one-sided expectations</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n_elements</strong> (<em>int</em>) – The number of elements</li>
<li><strong>n_clusters1</strong> (<em>int</em>) – optional
The number of clusters in the first clustering</li>
<li><strong>n_clusters2</strong> (<em>int</em>) – optional
The number of clusters in the second clustering, considered the
gold-standard clustering for the one-sided expecations</li>
<li><strong>clu_size_seq1</strong> (<em>list</em>) – optional
The cluster size seqence of the first clustering as a list of ints</li>
<li><strong>clu_size_seq2</strong> (<em>list</em>) – optional
The cluster size seqence of the second clustering as a list of ints</li>
<li><strong>random_model</strong> (<em>str</em>) – <p>The random model to use:</p>
<dl class="docutils">
<dt>’all’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements</dd>
<dt>’all1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements</dd>
<dt>’num’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements in n_clusters</dd>
<dt>’num1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements in n_clusters</dd>
</dl>
<p>’perm’ : the permutation model for a fixed cluster size sequence</p>
<dl class="docutils">
<dt>’perm1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the permutation model for a fixed</span></dt>
<dd>cluster size sequence, same as ‘perm’</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The expected Rand index (between 0.0 and 1.0)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_rand_index</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_rand_index</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all1&#39;</span><span class="p">,</span>
<span class="go">                                     clu_size_seq2=[1,1,3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_rand_index</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num&#39;</span><span class="p">,</span>
<span class="go">                                     n_clusters1=2, n_clusters2=3))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_rand_index</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num1&#39;</span><span class="p">,</span>
<span class="go">                                     n_clusters1=2, clu_size_seq2=[1,1,3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_rand_index</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm&#39;</span><span class="p">,</span>
<span class="go">                                     clu_size_seq1=[2,3],</span>
<span class="go">                                     clu_size_seq2=[1,1,3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_rand_index</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm1&#39;</span><span class="p">,</span>
<span class="go">                                     clu_size_seq1=[2,3],</span>
<span class="go">                                     clu_size_seq2=[1,1,3]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.adjrand_index">
<code class="descclassname">clusim.sim.</code><code class="descname">adjrand_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em>, <em>random_model='perm'</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.adjrand_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the adjusted Rand index for one of six random
models.</p>
<p>See <a class="reference internal" href="#hubert1985adjrand" id="id9">[HA85]</a> and <a class="reference internal" href="#gates2017impact" id="id10">[GA17]</a> for a detailed derivation and explaination of the different
random models.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Clustering 2 is considered the gold-standard clustering for one-sided expectations</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
<li><strong>random_model</strong> (<em>str</em>) – <p>The random model to use:</p>
<dl class="docutils">
<dt>’all’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements</dd>
<dt>’all1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements</dd>
<dt>’num’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements in n_clusters</dd>
<dt>’num1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements in n_clusters</dd>
</dl>
<p>’perm’ : the permutation model for a fixed cluster size sequence</p>
<dl class="docutils">
<dt>’perm1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the permutation model for a fixed</span></dt>
<dd>cluster size sequence, same as ‘perm’</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The adjusted_rand Rand index</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;all&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="go">                                                random_model=&#39;all&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adjrand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span>
<span class="go">                               random_model=&#39;all&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adjrand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span>
<span class="go">                               random_model=&#39;all1&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adjrand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span>
<span class="go">                               random_model=&#39;num&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adjrand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span>
<span class="go">                               random_model=&#39;num1&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adjrand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span>
<span class="go">                               random_model=&#39;perm&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adjrand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span>
<span class="go">                               random_model=&#39;perm1&#39;))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.adj_mi">
<code class="descclassname">clusim.sim.</code><code class="descname">adj_mi</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em>, <em>random_model='perm'</em>, <em>norm_type='sum'</em>, <em>logbase=2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.adj_mi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the adjusted Mutual Information for one of six random
models.</p>
<p>See <a class="reference internal" href="#gates2017impact" id="id11">[GA17]</a> for a detailed derivation and explaination of the different
random models.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Clustering 2 is considered the gold-standard clustering for one-sided expectations</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
<li><strong>random_model</strong> (<em>string</em>) – <p>The random model to use:</p>
<p>’all’ : uniform distrubtion over the set of all clusterings of n_elements</p>
<dl class="docutils">
<dt>’all1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements</dd>
<dt>’num’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements in n_clusters</dd>
<dt>’num1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements in n_clusters</dd>
</dl>
<p>’perm’ : the permutation model for a fixed cluster size sequence</p>
<dl class="docutils">
<dt>’perm1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the permutation model for a fixed</span></dt>
<dd>cluster size sequence, same as ‘perm’</dd>
</dl>
</li>
<li><strong>norm_type</strong> (<em>str</em>) – ‘sum’ (default), ‘max’, ‘min’, ‘sqrt’, ‘none’
The normalization type:
‘sum’ uses the average of the two clustering entropies,
‘max’ uses the maximum of the two clustering entropies,
‘min’ uses the minimum of the two clustering entropies,
‘sqrt’ uses the geometric mean of the two clustering entropies,
‘none’ returns the Mutual Information without a normalization</li>
<li><strong>logbase</strong> (<em>float</em>) – (default) 2
The base of all logarithms (recommended to use 2 for bits).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The adjusted Mutual Information</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adj_mi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adj_mi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adj_mi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span><span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adj_mi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span><span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adj_mi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span><span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">adj_mi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span><span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm1&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.expected_mi">
<code class="descclassname">clusim.sim.</code><code class="descname">expected_mi</code><span class="sig-paren">(</span><em>n_elements</em>, <em>n_clusters1=2</em>, <em>n_clusters2=2</em>, <em>clu_size_seq1=None</em>, <em>clu_size_seq2=None</em>, <em>logbase=2</em>, <em>random_model='num'</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.expected_mi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the expectation of the Mutual Informaiton between all
pairs of clusterings drawn from one of six random models.</p>
<p>See <a class="reference internal" href="#gates2017impact" id="id12">[GA17]</a> for a detailed derivation and explaination of the different
random models.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Clustering 2 is considered the gold-standard clustering for one-sided expectations</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n_elements</strong> (<em>int</em>) – The number of elements</li>
<li><strong>n_clusters1</strong> (<em>int</em>) – optional
The number of clusters in the first clustering</li>
<li><strong>n_clusters2</strong> (<em>int</em>) – optional
The number of clusters in the second clustering, considered the
gold-standard clustering for the one-sided expecations</li>
<li><strong>clu_size_seq1</strong> (<em>list</em>) – optional
The cluster size seqence of the first clustering as a list of ints.</li>
<li><strong>clu_size_seq2</strong> (<em>list</em>) – optional
The cluster size seqence of the second clustering as a list of ints.</li>
<li><strong>random_model</strong> (<em>str</em>) – <p>The random model to use:</p>
<dl class="docutils">
<dt>’all’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements</dd>
<dt>’all1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements</dd>
<dt>’num’ <span class="classifier-delimiter">:</span> <span class="classifier">uniform distrubtion over the set of all clusterings of</span></dt>
<dd>n_elements in n_clusters</dd>
<dt>’num1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the uniform distrubtion over the set</span></dt>
<dd>of all clusterings of n_elements in n_clusters</dd>
</dl>
<p>’perm’ : the permutation model for a fixed cluster size sequence</p>
<dl class="docutils">
<dt>’perm1’ <span class="classifier-delimiter">:</span> <span class="classifier">one-sided selction from the permutation model for a fixed</span></dt>
<dd>cluster size sequence, same as ‘perm’</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The expected MI (between 0.0 and inf)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_mi</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_mi</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;all1&#39;</span><span class="p">,</span>
<span class="go">                                     clu_size_seq2=[1,1,3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_mi</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num&#39;</span><span class="p">,</span>
<span class="go">                                     n_clusters1=2, n_clusters2=3))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_mi</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num1&#39;</span><span class="p">,</span>
<span class="go">                                     n_clusters1=2, clu_size_seq2=[1,1,3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_mi</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm&#39;</span><span class="p">,</span>
<span class="go">                                     clu_size_seq1=[2,3],</span>
<span class="go">                                     clu_size_seq2=[1,1,3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">expected_mi</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm1&#39;</span><span class="p">,</span>
<span class="go">                                     clu_size_seq1=[2,3],</span>
<span class="go">                                     clu_size_seq2=[1,1,3]))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="overlapping-clustering-similarity">
<h2>Overlapping Clustering Similarity<a class="headerlink" href="#overlapping-clustering-similarity" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="clusim.sim.onmi">
<code class="descclassname">clusim.sim.</code><code class="descname">onmi</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.onmi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the overlaping normalized mututal information.</p>
<p>See <a class="reference internal" href="#lancichinetti2009onmi" id="id13">[LFK09]</a> for a detailed derivation and explaination of the measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the overlaping normalized mutual information</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.omega_index">
<code class="descclassname">clusim.sim.</code><code class="descname">omega_index</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.omega_index" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the omega index between two clusterings.</p>
<p>See <a class="reference internal" href="#collins1988omega" id="id14">[CD88]</a> for a detailed derivation and explaination of the measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the omega index</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.geometric_accuracy">
<code class="descclassname">clusim.sim.</code><code class="descname">geometric_accuracy</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.geometric_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the geometric accuracy between two (overlapping) clusterings.</p>
<p>See <a class="reference internal" href="#nepusz2012overlapprotein" id="id15">[NYP12]</a> for a detailed derivation and explaination of the measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the geometric accuracy</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="clusim.sim.overlap_quality">
<code class="descclassname">clusim.sim.</code><code class="descname">overlap_quality</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.sim.overlap_quality" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the overlap quality between two (overlapping) clusterings.</p>
<p>See <a class="reference internal" href="#ahn2010link" id="id16">[ABL10]</a> for a detailed derivation and explaination of the measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first clustering.</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second clustering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the overlap quality</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-clusim.clusimelement">
<span id="element-centric-clustering-similarity"></span><h1>Element-centric Clustering Similarity<a class="headerlink" href="#module-clusim.clusimelement" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-clusimelement"></span><dl class="function">
<dt id="clusim.clusimelement.element_sim">
<code class="descclassname">clusim.clusimelement.</code><code class="descname">element_sim</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em>, <em>alpha=0.9</em>, <em>r=1.0</em>, <em>r2=None</em>, <em>rescale_path_type='max'</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clusimelement.element_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>The element-centric clustering similarity.</p>
<p>See <a class="reference internal" href="#gates2018element" id="id17">[GWHA18]</a> for a detailed explaination of the measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first Clustering</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second Clustering</li>
<li><strong>alpha</strong> (<em>float</em>) – The personalized page-rank return probability as a float in [0,1].</li>
<li><strong>r1</strong> (<em>float</em>) – The hierarchical scaling parameter for clustering1.</li>
<li><strong>r2</strong> (<em>float</em>) – The hierarchical scaling parameter for clustering2. This defaults to None
forcing r2 = r1</li>
<li><strong>rescale_path_type</strong> (<em>str</em>) – rescale the hierarchical height by
‘max’ : the maximum path from the root
‘min’ : the minimum path form the root
‘linkage’ : use the linkage distances in the clustering</li>
<li><strong>relabeled_elements</strong> (<em>dict</em>) – (optional)
The elements maped to indices of the affinity matrix.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The element-wise similarity between the two clusterings</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="go">                                           3:[1], 4:[2], 5:[2]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="go">                                           3:[1], 4:[2], 5:[1,2]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">element_sim</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clusimelement.element_sim_elscore">
<code class="descclassname">clusim.clusimelement.</code><code class="descname">element_sim_elscore</code><span class="sig-paren">(</span><em>clustering1</em>, <em>clustering2</em>, <em>alpha=0.9</em>, <em>r=1.0</em>, <em>r2=None</em>, <em>rescale_path_type='max'</em>, <em>relabeled_elements=None</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clusimelement.element_sim_elscore" title="Permalink to this definition">¶</a></dt>
<dd><p>The element-centric clustering similarity for each element.</p>
<p>See <a class="reference internal" href="#gates2018element" id="id18">[GWHA18]</a> for a detailed explaination of the measure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering1</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The first Clustering</li>
<li><strong>clustering2</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The second Clustering</li>
<li><strong>alpha</strong> (<em>float</em>) – The personalized page-rank return probability as a float in [0,1].</li>
<li><strong>r1</strong> (<em>float</em>) – The hierarchical scaling parameter for clustering1.</li>
<li><strong>r2</strong> (<em>float</em>) – The hierarchical scaling parameter for clustering2.  This defaults to None
forcing r2 = r1</li>
<li><strong>rescale_path_type</strong> (<em>str</em>) – rescale the hierarchical height by:
‘max’ : the maximum path from the root
‘min’ : the minimum path form the root
‘linkage’ : use the linkage distances in the clustering</li>
<li><strong>relabeled_elements</strong> (<em>dict</em>) – (optional)
The elements maped to indices of the affinity matrix.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-centric similarity between the two clusterings for each element as a 1d numpy array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a dict mapping each element to its index of the elementScores array.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="go">                                           3:[1], 4:[2], 5:[2]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="go">                                           3:[1], 4:[2], 5:[1,2]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elementScores</span><span class="p">,</span> <span class="n">relabeled_elements</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">element_sim_elseq</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span>
<span class="go">                                                          clustering2,</span>
<span class="go">                                                          alpha = 0.9)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">elementScores</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clusimelement.cL1">
<code class="descclassname">clusim.clusimelement.</code><code class="descname">cL1</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clusimelement.cL1" title="Permalink to this definition">¶</a></dt>
<dd><p>The normalized similarity value based on the L1 probabilty metric
corrected for the guaranteed overlap in probability between the two
vectors, alpha.</p>
<p>See <a class="reference internal" href="#gates2018element" id="id19">[GWHA18]</a> for a detailed explaination of the need to correct
the L1 metric.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>2d-numpy-array</em>) – The first list of probability vectors</li>
<li><strong>y</strong> (<em>2d-numpy-array</em>) – The second list of probability vectors</li>
<li><strong>alpha</strong> (<em>float</em>) – The guaranteed overlap in probability between the two vectors in [0,1].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The 1d numpy array of L1 similarities between the affinity matrices x and y</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="clusim.clusimelement.make_affinity_matrix">
<code class="descclassname">clusim.clusimelement.</code><code class="descname">make_affinity_matrix</code><span class="sig-paren">(</span><em>clustering</em>, <em>alpha=0.9</em>, <em>r=1.0</em>, <em>rescale_path_type='max'</em>, <em>relabeled_elements=None</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clusimelement.make_affinity_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The element-centric clustering similarity affinity matrix for a
clustering.  This function automatically determines the most efficient method
to calculate the affinity matrix.</p>
<p>See <a class="reference internal" href="#gates2018element" id="id20">[GWHA18]</a> for a detailed explaination of the affinity matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The clustering</li>
<li><strong>alpha</strong> (<em>float</em>) – The personalized page-rank return probability.</li>
<li><strong>relabeled_elements</strong> (<em>dict</em>) – (optional)
The elements maped to indices of the affinity matrix.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The element-centric affinity representation of the clustering as a 2d numpy array</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span>
<span class="go">                                           4:[2], 5:[2]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprmatrix</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">make_affinity_matrix</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pprmatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering2</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span>
<span class="go">                                           4:[2], 5:[2]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprmatrix2</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">make_affinity_matrix</span><span class="p">(</span><span class="n">clustering2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pprmatrix2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clusimelement.ppr_partition">
<code class="descclassname">clusim.clusimelement.</code><code class="descname">ppr_partition</code><span class="sig-paren">(</span><em>clustering</em>, <em>alpha=0.9</em>, <em>relabeled_elements=None</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clusimelement.ppr_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>The element-centric clustering similarity affinity matrix for a partition found analytically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The Clustering</li>
<li><strong>alpha</strong> (<em>float</em>) – The personalized page-rank return probability as a float in [0,1].</li>
<li><strong>relabeled_elements</strong> (<em>dict</em>) – (optional)
The elements maped to indices of the affinity matrix.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2d numpy array
The element-centric affinity representation of the clustering</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="o">=</span><span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprmatrix</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">ppr_partition</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pprmatrix</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clusimelement.make_cielg">
<code class="descclassname">clusim.clusimelement.</code><code class="descname">make_cielg</code><span class="sig-paren">(</span><em>clustering</em>, <em>r=1.0</em>, <em>rescale_path_type='max'</em>, <em>relabeled_elements=None</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clusimelement.make_cielg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the cluster-induced element graph for a Clustering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustering</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The clustering</li>
<li><strong>r</strong> (<em>float</em>) – The hierarchical scaling parameter.</li>
<li><strong>rescale_path_type</strong> (<em>str</em>) – rescale the hierarchical height by:
‘max’ : the maximum path from the root
‘min’ : the minimum path form the root
‘linkage’ : use the linkage distances in the clustering</li>
<li><strong>relabeled_elements</strong> (<em>dict</em>) – (optional)
The elements maped to indices of the affinity matrix.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The cluster-induced element graph for a Clustering as an igraph.WeightedGraph</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">clusim.sim</span> <span class="k">as</span> <span class="nn">sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clusim.clustering</span> <span class="k">import</span> <span class="n">Clustering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elm2clu_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">:[</span><span class="mi">2</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clustering1</span> <span class="o">=</span> <span class="n">Clustering</span><span class="p">(</span><span class="n">elm2clu_dict</span><span class="o">=</span><span class="n">elm2clu_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprmatrix</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">make_cielg</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pprmatrix</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="clusim.clusimelement.find_groups_in_cluster">
<code class="descclassname">clusim.clusimelement.</code><code class="descname">find_groups_in_cluster</code><span class="sig-paren">(</span><em>clustervs</em>, <em>elementgroupList</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clusimelement.find_groups_in_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility function to find vertices with the same cluster
memberships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clustervs</strong> (<em>igraph.vertex</em>) – an igraph vertex instance</li>
<li><strong>elementgroupList</strong> (<em>list</em>) – a list containing the vertices to group</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list-of-lists containing the groupings of the vertices</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="clusim.clusimelement.numerical_ppr_scores">
<code class="descclassname">clusim.clusimelement.</code><code class="descname">numerical_ppr_scores</code><span class="sig-paren">(</span><em>cielg</em>, <em>clustering</em>, <em>alpha=0.9</em>, <em>relabeled_elements=None</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.clusimelement.numerical_ppr_scores" title="Permalink to this definition">¶</a></dt>
<dd><p>The element-centric clustering similarity affinity matrix for a partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cielg</strong> (<em>igraph.WeightedGraph</em>) – cielg : An igraph Weighted Graph representation of the cluster-induced element graph</li>
<li><strong>clustering</strong> (<a class="reference internal" href="#clusim.clustering.Clustering" title="clusim.clustering.Clustering"><em>Clustering</em></a>) – The Clustering</li>
<li><strong>alpha</strong> (<em>float</em>) – The personalized page-rank return probability as a float in [0,1].</li>
<li><strong>relabeled_elements</strong> (<em>dict</em>) – (optional) dict
The elements maped to indices of the affinity matrix.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2d numpy array
The element-centric affinity representation of the clustering</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-clusim.dag">
<span id="dag-and-dendrogram"></span><h1>DAG and Dendrogram<a class="headerlink" href="#module-clusim.dag" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-dag"></span><dl class="class">
<dt id="clusim.dag.DAG">
<em class="property">class </em><code class="descclassname">clusim.dag.</code><code class="descname">DAG</code><span class="sig-paren">(</span><em>incoming_graph_data=None</em>, <em>**attr</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.dag.DAG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="clusim.dag.Dendrogram">
<em class="property">class </em><code class="descclassname">clusim.dag.</code><code class="descname">Dendrogram</code><span class="sig-paren">(</span><em>incoming_graph_data=None</em>, <em>**attr</em><span class="sig-paren">)</span><a class="headerlink" href="#clusim.dag.Dendrogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="references">
<h1>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h1>
<p id="bibtex-bibliography-clusim-0"><table class="docutils citation" frame="void" id="ahn2010link" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[ABL10]</a></td><td>Yong-Yeol Ahn, James&nbsp;P Bagrow, and Sune Lehmann. Link communities reveal multiscale complexity in networks. <em>Nature</em>, 466(7307):761–764, June 2010.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="collins1988omega" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[CD88]</a></td><td>Linda&nbsp;M. Collins and Clyde&nbsp;W. Dent. Omega: a general formulation of the rand index of cluster recovery suitable for non-disjoint solutions. <em>Multivariate Behavioral Research</em>, 23(2):231–242, 1988.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="danon2005comparingcomm" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[DDiazGDA05]</a></td><td>Leon Danon, Albert D&nbsp;ıaz-Guilera, Jordi Duch, and Alex Arenas. Comparing community structure identification. <em>Journal of Statistical Mechanics: Theory and Experiment</em>, 2005(09):P09008–P09008, September 2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="fowlkes1983hierarchicalcompare" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[FM83]</a></td><td>Edward&nbsp;B. Fowlkes and Colin&nbsp;L. Mallows. A method for comparing two hierarchical clusterings. <em>Journal of the American Statistical Association</em>, 78(383):553–569, 1983.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gates2017impact" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[GA17]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id8">2</a>, <a class="fn-backref" href="#id10">3</a>, <a class="fn-backref" href="#id11">4</a>, <a class="fn-backref" href="#id12">5</a>)</em> Alexander&nbsp;J. Gates and Yong-Yeol Ahn. The impact of random models on clustering similarity. <em>Journal of Machine Learning Research</em>, 18(87):1–28, 2017.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gates2018element" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[GWHA18]</td><td><em>(<a class="fn-backref" href="#id17">1</a>, <a class="fn-backref" href="#id18">2</a>, <a class="fn-backref" href="#id19">3</a>, <a class="fn-backref" href="#id20">4</a>)</em> Alexander&nbsp;J. Gates, Ian&nbsp;B. Wood, William&nbsp;P. Hetrick, and Yong-Yeol Ahn. On comparing clusterings: an element-centric framework unifies overlaps and hierarchy. <em>arxiv</em>, pages 1706.06136, 2018.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hubert1985adjrand" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[HA85]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> Lawrence Hubert and Phipps Arabie. Comparing partitions. <em>Journal of Classification</em>, 2(1):193–218, December 1985.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="jaccard1912flora" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[Jac12]</a></td><td>Paul Jaccard. The distribution of the flora in the alpine zone. <em>New Phytologist</em>, 11(2):37–50, 1912.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="lancichinetti2009onmi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[LFK09]</a></td><td>Andrea Lancichinetti, Santo Fortunato, and János Kertész. Detecting the overlapping and hierarchical community structure in complex networks. <em>New Journal of Physics</em>, 11(3):033015, 3 2009.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="meila2003comparingvi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[Mei03]</a></td><td>Marina Meilă. Comparing clusterings by the variation of information. In <em>Learning Theory and Kernel Machines</em>, pages 173–187. Springer, 2003.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="nepusz2012overlapprotein" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[NYP12]</a></td><td>Tamás Nepusz, Haiyuan Yu, and Alberto Paccanaro. Detecting overlapping protein complexes in protein-protein interaction networks. <em>Nature Methods</em>, 9(5):471–472, 2012.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rand1971randindex" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Ran71]</a></td><td>William&nbsp;M Rand. Objective Criteria for the Evaluation of Clustering Methods. <em>Journal of the American Statistical Association</em>, 66(336):846, 1971.</td></tr>
</tbody>
</table>
</p>
</div>


          </div>
            
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">CluSim  documentation</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2018, Alexander J Gates and Yong-Yeol Ahn. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>