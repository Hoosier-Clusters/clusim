
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>clusim.sim &#8212; clusim 0.4 documentation</title>
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../clusim.html">clusim 0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for clusim.sim</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: sim</span>
<span class="sd">    :synopsis: Calculate similarity between clusterings using pair-wise and information</span>
<span class="sd">        theoretic measures.</span>

<span class="sd">.. moduleauthor:: Alex Gates &lt;ajgates42@gmail.com&gt;</span>
<span class="sd"> &quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
<span class="kn">import</span> <span class="nn">mpmath</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">sps</span>

<span class="kn">import</span> <span class="nn">clusim.clugen</span> <span class="k">as</span> <span class="nn">clugen</span>
<span class="kn">from</span> <span class="nn">clusim.clusimelement</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">clusim.clusteringerror</span> <span class="kn">import</span> <span class="n">ClusteringSimilarityError</span>

<span class="n">available_similarity_measures</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;rand_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;adjrand_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;fowlkes_mallows_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;fmeasure&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;purity_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;classification_error&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;czekanowski_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;dice_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;sorensen_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;rogers_tanimoto_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;southwood_index&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;pearson_correlation&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;corrected_chance&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;sample_expected_sim&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;nmi&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;mi&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;adj_mi&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;rmi&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;vi&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;geometric_accuracy&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;overlap_quality&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;onmi&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;omega_index&#39;</span><span class="p">]</span>

<span class="n">available_random_models</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;perm&#39;</span><span class="p">,</span> <span class="s1">&#39;perm1&#39;</span><span class="p">,</span> <span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;num1&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;all1&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="contingency_table"><a class="viewcode-back" href="../../clusim.html#clusim.sim.contingency_table">[docs]</a><span class="k">def</span> <span class="nf">contingency_table</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function creates the contingency table between two clusterings.</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The clustering1.n_clusters by clustering2.n_clusters contingency table as a list of lists</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                             random_model = &#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                             random_model = &#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; cont_table = contingency_table(clustering1, clustering2)</span>
<span class="sd">    &gt;&gt;&gt; print(cont_table)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">!=</span> <span class="n">clustering2</span><span class="o">.</span><span class="n">n_elements</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ClusteringSimilarityError</span>

    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">e1</span> <span class="o">!=</span> <span class="n">e2</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">clustering2</span><span class="o">.</span><span class="n">elements</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ClusteringSimilarityError</span>

    <span class="k">return</span> <span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu2elm_dict</span><span class="p">[</span><span class="n">clu1</span><span class="p">]</span> <span class="o">&amp;</span>
                 <span class="n">clustering2</span><span class="o">.</span><span class="n">clu2elm_dict</span><span class="p">[</span><span class="n">clu2</span><span class="p">])</span>
             <span class="k">for</span> <span class="n">clu2</span> <span class="ow">in</span> <span class="n">clustering2</span><span class="o">.</span><span class="n">clusters</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">clu1</span> <span class="ow">in</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">clusters</span><span class="p">]</span></div>


<div class="viewcode-block" id="count_pairwise_cooccurence"><a class="viewcode-back" href="../../clusim.html#clusim.sim.count_pairwise_cooccurence">[docs]</a><span class="k">def</span> <span class="nf">count_pairwise_cooccurence</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function finds the pairwise cooccurence counts between two</span>
<span class="sd">    clusterings.</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        N11 : int</span>
<span class="sd">            The number of element pairs assigned to the same clusters in both</span>
<span class="sd">            clusterings</span>

<span class="sd">        N10 : int</span>
<span class="sd">            The number of element pairs assigned to the same clusters in</span>
<span class="sd">            clustering1, but different clusters in clustering2</span>

<span class="sd">        N01 : int</span>
<span class="sd">            The number of element pairs assigned to different clusters in</span>
<span class="sd">            clustering1, but the same clusters in clustering2</span>

<span class="sd">        N00 : int</span>
<span class="sd">            The number of element pairs assigned to different clusters in both</span>
<span class="sd">            clusterings</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; from clusim.clustering import print_clustering</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                             random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                             random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; N11, N10, N01, N00 = sim.count_pairwise_cooccurence(clustering1,</span>
<span class="sd">                                                        clustering2)</span>
<span class="sd">    &gt;&gt;&gt; print_clustering(clustering1)</span>
<span class="sd">    &gt;&gt;&gt; print_clustering(clustering2)</span>
<span class="sd">    &gt;&gt;&gt; print(N11,</span>
<span class="sd">            &quot;element pairs assigned to the same clusters in both clusterings&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(N10,</span>
<span class="sd">            &quot;element pairs assigned to the same clusters in clustering1, but &quot;</span>
<span class="sd">            &quot;different clusters in clustering2&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(N01, &quot;element pairs assigned to different clusters in &quot;</span>
<span class="sd">                   &quot;clustering1, but the same clusters in clustering2&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(N00, &quot;element pairs assigned to different clusters in both &quot;</span>
<span class="sd">                   &quot;clusterings&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cont_tbl</span> <span class="o">=</span> <span class="n">contingency_table</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">))</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">))</span>

    <span class="n">N11</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>
    <span class="n">N10</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">N01</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">N00</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">*</span> <span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>\
        <span class="n">N11</span> <span class="o">-</span> <span class="n">N10</span> <span class="o">-</span> <span class="n">N01</span>

    <span class="k">return</span> <span class="n">N11</span><span class="p">,</span> <span class="n">N10</span><span class="p">,</span> <span class="n">N01</span><span class="p">,</span> <span class="n">N00</span></div>


<span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="n">prob_vector</span><span class="p">,</span> <span class="n">logbase</span><span class="o">=</span><span class="mf">2.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Entropy of a probability vector that sums too one.&quot;&quot;&quot;</span>
    <span class="n">prob_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prob_vector</span><span class="p">)</span>
    <span class="n">pos_prob_vector</span> <span class="o">=</span> <span class="n">prob_vector</span><span class="p">[</span><span class="n">prob_vector</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pos_prob_vector</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pos_prob_vector</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">))</span>


<span class="n">binary_entropy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">logbase</span><span class="o">=</span><span class="mi">2</span><span class="p">:</span> <span class="n">entropy</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="n">logbase</span><span class="o">=</span><span class="n">logbase</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">hyper</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Probability mass function of the hypergeometric distribution.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span>\
        <span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">These are the Pairwise Co-occurence Measures</span>
<span class="sd">&#39;&#39;&#39;</span>


<div class="viewcode-block" id="jaccard_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.jaccard_index">[docs]</a><span class="k">def</span> <span class="nf">jaccard_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Jaccard index between two clusterings :cite:`Jaccard1912flora`.</span>

<span class="sd">    J = N11/(N11+N10+N01)</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Jaccard index (between 0.0 and 1.0)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen..make_random_clustering(n_elements=9,</span>
<span class="sd">                                                    n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9,</span>
<span class="sd">                                                    n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.jaccard_index(clustering1, clustering2) )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N11</span><span class="p">,</span> <span class="n">N10</span><span class="p">,</span> <span class="n">N01</span><span class="p">,</span> <span class="n">N00</span> <span class="o">=</span> <span class="n">count_pairwise_cooccurence</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="n">denom</span> <span class="o">=</span> <span class="n">N11</span> <span class="o">+</span> <span class="n">N10</span> <span class="o">+</span> <span class="n">N01</span>

    <span class="c1"># catch the case every element is in its own cluster so denominator is 0</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">N11</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="rand_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.rand_index">[docs]</a><span class="k">def</span> <span class="nf">rand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Rand index between two clusterings :cite:`Rand1971randindex`.</span>

<span class="sd">    RI = (N11 + N00) / (N11 + N10 + N01 + N00)</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Rand index (between 0.0 and 1.0)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen..make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.rand_index(clustering1, clustering2))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N11</span><span class="p">,</span> <span class="n">N10</span><span class="p">,</span> <span class="n">N01</span><span class="p">,</span> <span class="n">N00</span> <span class="o">=</span> <span class="n">count_pairwise_cooccurence</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">N11</span> <span class="o">+</span> <span class="n">N00</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N11</span> <span class="o">+</span> <span class="n">N10</span> <span class="o">+</span> <span class="n">N01</span> <span class="o">+</span> <span class="n">N00</span><span class="p">)</span></div>


<div class="viewcode-block" id="expected_rand_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.expected_rand_index">[docs]</a><span class="k">def</span> <span class="nf">expected_rand_index</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="n">n_clusters1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                        <span class="n">n_clusters2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">clu_size_seq1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clu_size_seq2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the expectation of the Rand index between all</span>
<span class="sd">    pairs of clusterings drawn from one of six random models.</span>

<span class="sd">    See :cite:`Hubert1985adjrand` and :cite:`Gates2017impact` for a detailed derivation and explanation of the different</span>
<span class="sd">    random models.</span>

<span class="sd">    .. note:: Clustering 2 is considered the gold-standard clustering for one-sided expectations</span>

<span class="sd">    :param int n_elements:</span>
<span class="sd">        The number of elements</span>

<span class="sd">    :param str random_model:</span>
<span class="sd">        The random model to use:</span>

<span class="sd">        &#39;all&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements</span>

<span class="sd">        &#39;all1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements</span>

<span class="sd">        &#39;num&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements in n_clusters</span>

<span class="sd">        &#39;num1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements in n_clusters</span>

<span class="sd">        &#39;perm&#39; : the permutation model for a fixed cluster size sequence</span>

<span class="sd">        &#39;perm1&#39; : one-sided selection from the permutation model for a fixed</span>
<span class="sd">                  cluster size sequence, same as &#39;perm&#39;</span>

<span class="sd">    :param int n_clusters1: optional</span>
<span class="sd">        The number of clusters in the first clustering</span>

<span class="sd">    :param int n_clusters2: optional</span>
<span class="sd">        The number of clusters in the second clustering, considered the</span>
<span class="sd">        gold-standard clustering for the one-sided expectations</span>

<span class="sd">    :param list clu_size_seq1: optional</span>
<span class="sd">        The cluster size sequence of the first clustering as a list of ints</span>

<span class="sd">    :param list clu_size_seq2: optional</span>
<span class="sd">        The cluster size sequence of the second clustering as a list of ints</span>

<span class="sd">    :returns:</span>
<span class="sd">        The expected Rand index (between 0.0 and 1.0)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_rand_index(n_elements=5, random_model=&#39;all&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_rand_index(n_elements=5, random_model=&#39;all1&#39;,</span>
<span class="sd">                                         clu_size_seq2=[1,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_rand_index(n_elements=5, , random_model=&#39;num&#39;,</span>
<span class="sd">                                         n_clusters1=2, n_clusters2=3))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_rand_index(n_elements=5, random_model=&#39;num1&#39;,</span>
<span class="sd">                                         n_clusters1=2, clu_size_seq2=[1,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_rand_index(n_elements=5, random_model=&#39;perm&#39;,</span>
<span class="sd">                                         clu_size_seq1=[2,3],</span>
<span class="sd">                                         clu_size_seq2=[1,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_rand_index(n_elements=5, random_model=&#39;perm1&#39;,</span>
<span class="sd">                                         clu_size_seq1=[2,3],</span>
<span class="sd">                                         clu_size_seq2=[1,1,3]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span> <span class="ow">or</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;perm1&#39;</span><span class="p">:</span>
        <span class="n">npairs</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">clu_size_seq1</span><span class="p">])</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">clu_size_seq2</span><span class="p">])</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">q</span> <span class="o">/</span> <span class="n">npairs</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span> <span class="o">/</span> <span class="n">npairs</span>

    <span class="k">elif</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;num&#39;</span><span class="p">:</span>
        <span class="n">QA1</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_clusters1</span><span class="p">)</span> <span class="o">/</span>\
            <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">n_clusters1</span><span class="p">)</span>
        <span class="n">QB1</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_clusters2</span><span class="p">)</span> <span class="o">/</span>\
            <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">n_clusters2</span><span class="p">)</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="n">QA1</span><span class="o">*</span><span class="n">QB1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">QA1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">QB1</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;num1&#39;</span><span class="p">:</span>
        <span class="n">QA1</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_clusters1</span><span class="p">)</span> <span class="o">/</span>\
            <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">n_clusters1</span><span class="p">)</span>
        <span class="n">QG1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">gi</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">clu_size_seq2</span><span class="p">])</span> <span class="o">/</span>\
            <span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="n">QA1</span><span class="o">*</span><span class="n">QG1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">QA1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">QG1</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">Q1</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">bell</span><span class="p">(</span><span class="n">n_elements</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">mpmath</span><span class="o">.</span><span class="n">bell</span><span class="p">(</span><span class="n">n_elements</span><span class="p">)</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="n">Q1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">Q1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">elif</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;all1&#39;</span><span class="p">:</span>

        <span class="n">QA1</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">bell</span><span class="p">(</span><span class="n">n_elements</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">mpmath</span><span class="o">.</span><span class="n">bell</span><span class="p">(</span><span class="n">n_elements</span><span class="p">)</span>
        <span class="n">QG1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">gi</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">clu_size_seq2</span><span class="p">])</span> <span class="o">/</span>\
            <span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="n">QA1</span><span class="o">*</span><span class="n">QG1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">QA1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">QG1</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39; TODO: random model not supported&#39;&#39;&#39;</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">expected</span><span class="p">)</span></div>


<div class="viewcode-block" id="adjrand_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.adjrand_index">[docs]</a><span class="k">def</span> <span class="nf">adjrand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the adjusted Rand index for one of six random</span>
<span class="sd">    models.</span>

<span class="sd">    See :cite:`Hubert1985adjrand` and :cite:`Gates2017impact` for a detailed derivation and explanation of the different</span>
<span class="sd">    random models.</span>

<span class="sd">    .. note:: Clustering 2 is considered the gold-standard clustering for one-sided expectations</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :param str random_model:</span>
<span class="sd">        The random model to use:</span>

<span class="sd">        &#39;all&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements</span>

<span class="sd">        &#39;all1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements</span>

<span class="sd">        &#39;num&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements in n_clusters</span>

<span class="sd">        &#39;num1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements in n_clusters</span>

<span class="sd">        &#39;perm&#39; : the permutation model for a fixed cluster size sequence</span>

<span class="sd">        &#39;perm1&#39; : one-sided selection from the permutation model for a fixed</span>
<span class="sd">                  cluster size sequence, same as &#39;perm&#39;</span>

<span class="sd">    :returns:</span>
<span class="sd">        The adjusted_rand Rand index</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adjrand_index(clustering1, clustering2,</span>
<span class="sd">                                   random_model=&#39;all&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adjrand_index(clustering1, clustering2,</span>
<span class="sd">                                   random_model=&#39;all1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adjrand_index(clustering1, clustering2,</span>
<span class="sd">                                   random_model=&#39;num&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adjrand_index(clustering1, clustering2,</span>
<span class="sd">                                   random_model=&#39;num1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adjrand_index(clustering1, clustering2,</span>
<span class="sd">                                   random_model=&#39;perm&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adjrand_index(clustering1, clustering2,</span>
<span class="sd">                                   random_model=&#39;perm1&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="n">exp_rand</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exp_rand</span> <span class="o">=</span> <span class="n">expected_rand_index</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">,</span>
                                       <span class="n">n_clusters1</span><span class="o">=</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span>
                                       <span class="n">n_clusters2</span><span class="o">=</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span>
                                       <span class="n">clu_size_seq1</span><span class="o">=</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span>
                                       <span class="n">clu_size_seq2</span><span class="o">=</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span>
                                       <span class="n">random_model</span><span class="o">=</span><span class="n">random_model</span><span class="p">)</span>

    <span class="n">denom</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">exp_rand</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">denom</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">rand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp_rand</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="fowlkes_mallows_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.fowlkes_mallows_index">[docs]</a><span class="k">def</span> <span class="nf">fowlkes_mallows_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Fowlkes and Mallows index between two</span>
<span class="sd">    clusterings :cite:`Fowlkes1983hierarchicalcompare`.</span>

<span class="sd">    FM = N11 / sqrt( (N11 + N10) * (N11 + N01) )</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Fowlkes and Mallows index (between 0.0 and 1.0)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.fowlkes_mallows_index(clustering1, clustering2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N11</span><span class="p">,</span> <span class="n">N10</span><span class="p">,</span> <span class="n">N01</span><span class="p">,</span> <span class="n">N00</span> <span class="o">=</span> <span class="n">count_pairwise_cooccurence</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">N11</span> <span class="o">+</span> <span class="n">N10</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N11</span> <span class="o">+</span> <span class="n">N01</span><span class="p">))</span>

    <span class="c1"># catch the case every element is in its own cluster so denominator is 0</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">N11</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="fmeasure"><a class="viewcode-back" href="../../clusim.html#clusim.sim.fmeasure">[docs]</a><span class="k">def</span> <span class="nf">fmeasure</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the F-measure between two clusterings.</span>

<span class="sd">    Also known as:</span>
<span class="sd">    Czekanowski index</span>
<span class="sd">    Dice Symmetric index</span>
<span class="sd">    Sorensen index</span>

<span class="sd">    F = 2*N11 / (2*N11 + N10 + N01)</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The F-measure (between 0.0 and 1.0)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.fmeasure(clustering1, clustering2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N11</span><span class="p">,</span> <span class="n">N10</span><span class="p">,</span> <span class="n">N01</span><span class="p">,</span> <span class="n">N00</span> <span class="o">=</span> <span class="n">count_pairwise_cooccurence</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N11</span> <span class="o">+</span> <span class="n">N10</span> <span class="o">+</span> <span class="n">N01</span><span class="p">)</span>

    <span class="c1"># catch the case every element is in its own cluster so denominator is 0</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">N11</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="purity_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.purity_index">[docs]</a><span class="k">def</span> <span class="nf">purity_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Purity index between two clusterings.</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Purity index (between 0.0 and 1.0)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.purity_index(clustering1, clustering2))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cont_tbl</span> <span class="o">=</span> <span class="n">contingency_table</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">*</span>\
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span>
                      <span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">])))</span></div>


<div class="viewcode-block" id="classification_error"><a class="viewcode-back" href="../../clusim.html#clusim.sim.classification_error">[docs]</a><span class="k">def</span> <span class="nf">classification_error</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Jaccard index between two clusterings.</span>

<span class="sd">    CE = 1 - PI</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Classification Error (between 0.0 and 1.0)</span>

<span class="sd">    .. note:: CE is a distance measure, it is 0 for identical clusterings</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.classification_error(clustering1, clustering2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">purity_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span></div>


<div class="viewcode-block" id="czekanowski_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.czekanowski_index">[docs]</a><span class="k">def</span> <span class="nf">czekanowski_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function calculates the Czekanowski index between two clusterings.</span>

<span class="sd">        See Fmeasure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fmeasure</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span></div>


<div class="viewcode-block" id="dice_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.dice_index">[docs]</a><span class="k">def</span> <span class="nf">dice_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function calculates the Dice index between two clusterings.</span>

<span class="sd">        See Fmeasure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fmeasure</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span></div>


<div class="viewcode-block" id="sorensen_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.sorensen_index">[docs]</a><span class="k">def</span> <span class="nf">sorensen_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function calculates the Sorensen index between two clusterings.</span>

<span class="sd">        See Fmeasure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fmeasure</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span></div>


<div class="viewcode-block" id="rogers_tanimoto_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.rogers_tanimoto_index">[docs]</a><span class="k">def</span> <span class="nf">rogers_tanimoto_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Rogers and Tanimoto index between two</span>
<span class="sd">    clusterings.</span>

<span class="sd">    RT = (N11 + N00)/(N11 + 2*(N10+N01) + N00)</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Rogers and Tanimoto index (between 0.0 and 1.0)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.rogers_tanimoto_index(clustering1, clustering2))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N11</span><span class="p">,</span> <span class="n">N10</span><span class="p">,</span> <span class="n">N01</span><span class="p">,</span> <span class="n">N00</span> <span class="o">=</span> <span class="n">count_pairwise_cooccurence</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">N11</span> <span class="o">+</span> <span class="n">N00</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">N11</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">N10</span><span class="o">+</span><span class="n">N01</span><span class="p">)</span> <span class="o">+</span> <span class="n">N00</span><span class="p">)</span></div>


<div class="viewcode-block" id="southwood_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.southwood_index">[docs]</a><span class="k">def</span> <span class="nf">southwood_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; calculate the southwood index</span>

<span class="sd">    N11 / (N10 + N01)</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Southwood index (between 0 and 1.0)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.southwood_index(clustering1, clustering2))</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N11</span><span class="p">,</span> <span class="n">N10</span><span class="p">,</span> <span class="n">N01</span><span class="p">,</span> <span class="n">N00</span> <span class="o">=</span> <span class="n">count_pairwise_cooccurence</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="n">denom</span> <span class="o">=</span> <span class="n">N10</span> <span class="o">+</span> <span class="n">N01</span>

    <span class="c1"># catch the case where the two clusters agree</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">N11</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span></div>


<div class="viewcode-block" id="pearson_correlation"><a class="viewcode-back" href="../../clusim.html#clusim.sim.pearson_correlation">[docs]</a><span class="k">def</span> <span class="nf">pearson_correlation</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Pearson Correlation between two clusterings.</span>

<span class="sd">    PC = (N11*N00 - N01*N10) / ((N11+N10) * (N11+N01) * (N00+N10) * (N00+N01))</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Pearson Correlation (between -1.0 and 1.0)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.pearson_correlation(clustering1, clustering2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N11</span><span class="p">,</span> <span class="n">N10</span><span class="p">,</span> <span class="n">N01</span><span class="p">,</span> <span class="n">N00</span> <span class="o">=</span> <span class="n">count_pairwise_cooccurence</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="n">numerator</span> <span class="o">=</span> <span class="n">N11</span> <span class="o">*</span> <span class="n">N00</span> <span class="o">-</span> <span class="n">N01</span> <span class="o">*</span> <span class="n">N10</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">N11</span> <span class="o">+</span> <span class="n">N10</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N11</span> <span class="o">+</span> <span class="n">N01</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N00</span> <span class="o">+</span> <span class="n">N10</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N00</span> <span class="o">+</span> <span class="n">N01</span><span class="p">)</span>

    <span class="c1"># catch the case every element is in its own cluster so denominator is 0</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="corrected_chance"><a class="viewcode-back" href="../../clusim.html#clusim.sim.corrected_chance">[docs]</a><span class="k">def</span> <span class="nf">corrected_chance</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span>
                     <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm&#39;</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the adjusted Similarity for one of six random</span>
<span class="sd">    models.</span>

<span class="sd">    .. note:: Clustering 2 is considered the gold-standard clustering for one-sided expectations</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :param str measure:</span>
<span class="sd">        The similarity measure to evaluate. Must be one of the</span>
<span class="sd">        available_similarity_measures.</span>

<span class="sd">    :param str random_model:</span>
<span class="sd">        The random model to use:</span>

<span class="sd">        &#39;all&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements</span>

<span class="sd">        &#39;all1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements</span>

<span class="sd">        &#39;num&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements in n_clusters</span>

<span class="sd">        &#39;num1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements in n_clusters</span>

<span class="sd">        &#39;perm&#39; : the permutation model for a fixed cluster size sequence</span>

<span class="sd">        &#39;perm1&#39; : one-sided selection from the permutation model for a fixed</span>
<span class="sd">                  cluster size sequence, same as &#39;perm&#39;</span>

<span class="sd">    :param str norm_type: &#39;sum&#39; (default), &#39;max&#39;, &#39;min&#39;, &#39;sqrt&#39;, &#39;none&#39;</span>
<span class="sd">        The normalization type used if the measure is &#39;nmi&#39;</span>
<span class="sd">        &#39;sum&#39; uses the average of the two clustering entropies,</span>
<span class="sd">        &#39;max&#39; uses the maximum of the two clustering entropies,</span>
<span class="sd">        &#39;min&#39; uses the minimum of the two clustering entropies,</span>
<span class="sd">        &#39;sqrt&#39; uses the geometric mean of the two clustering entropies,</span>
<span class="sd">        &#39;none&#39; returns the Mutual Information without a normalization</span>

<span class="sd">    n_samples : int</span>
<span class="sd">        The number of random Clusterings sampled to determine the expected</span>
<span class="sd">        similarity.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The adjusted Similarity measure</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.corrected_chance(clustering1, clustering2, measure=&#39;jaccard_index&#39;,</span>
<span class="sd">                                      random_model=&#39;all&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.corrected_chance(clustering1, clustering2, measure=&#39;jaccard_index&#39;,</span>
<span class="sd">                                      random_model=&#39;all1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.corrected_chance(clustering1, clustering2, measure=&#39;jaccard_index&#39;,</span>
<span class="sd">                                      random_model=&#39;num&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.corrected_chance(clustering1, clustering2, measure=&#39;jaccard_index&#39;,</span>
<span class="sd">                                      random_model=&#39;num1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.corrected_chance(clustering1, clustering2, measure=&#39;jaccard_index&#39;,</span>
<span class="sd">                                      random_model=&#39;perm&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.corrected_chance(clustering1, clustering2, measure=&#39;jaccard_index&#39;,</span>
<span class="sd">                                      random_model=&#39;perm1&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># catch the two cases (rand_index or nmi) that can be found</span>
    <span class="k">if</span> <span class="n">measure</span> <span class="o">==</span> <span class="s1">&#39;rand_index&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adjrand_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span>
                             <span class="n">random_model</span><span class="o">=</span><span class="n">random_model</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">measure</span> <span class="o">==</span> <span class="s1">&#39;nmi&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adj_mi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="n">random_model</span><span class="p">,</span>
                      <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">)</span>

    <span class="c1"># otherwise, make sure the measure is an available measure</span>
    <span class="k">elif</span> <span class="n">measure</span> <span class="ow">in</span> <span class="n">available_similarity_measures</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">exp_sim</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exp_sim</span> <span class="o">=</span> <span class="n">sample_expected_sim</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span>
                                          <span class="n">measure</span><span class="o">=</span><span class="n">measure</span><span class="p">,</span>
                                          <span class="n">random_model</span><span class="o">=</span><span class="n">random_model</span><span class="p">,</span>
                                          <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">)</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">exp_sim</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">denom</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">similarity_value</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">measure</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;(clustering1, clustering2)&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">similarity_value</span> <span class="o">-</span> <span class="n">exp_sim</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Measure </span><span class="si">%s</span><span class="s2"> not supported. &quot;</span>
              <span class="s2">&quot;Please choose from one of the available measures:&quot;</span> <span class="o">%</span> <span class="n">measure</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">available_similarity_measures</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="sample_expected_sim"><a class="viewcode-back" href="../../clusim.html#clusim.sim.sample_expected_sim">[docs]</a><span class="k">def</span> <span class="nf">sample_expected_sim</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;jaccard_index&#39;</span><span class="p">,</span>
                        <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keep_samples</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the expected Similarity for all pair-wise</span>
<span class="sd">    comparisons between Clusterings drawn from one of six random models.</span>

<span class="sd">    .. note:: Clustering 2 is considered the gold-standard clustering for one-sided expectations</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :param str measure:</span>
<span class="sd">        The similarity measure to evaluate. Must be one of the measures listed in</span>
<span class="sd">        sim.available_similarity_measures.</span>

<span class="sd">    :param string random_model:</span>
<span class="sd">        The random model to use:</span>

<span class="sd">        &#39;all&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements</span>

<span class="sd">        &#39;all1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements</span>

<span class="sd">        &#39;num&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements in n_clusters</span>

<span class="sd">        &#39;num1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements in n_clusters</span>

<span class="sd">        &#39;perm&#39; : the permutation model for a fixed cluster size sequence</span>

<span class="sd">        &#39;perm1&#39; : one-sided selection from the permutation model for a fixed</span>
<span class="sd">                  cluster size sequence, same as &#39;perm&#39;</span>

<span class="sd">    :param int n_samples:</span>
<span class="sd">        The number of random Clusterings sampled to determine the expected</span>
<span class="sd">        similarity.</span>

<span class="sd">    :param bool keep_samples:</span>
<span class="sd">        If True, returns the Similarity samples themselves, otherwise return their mean.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The expected Similarity measure for all pair-wise comparisons under a</span>
<span class="sd">        random model</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; c1 = clugen.make_random_clustering(n_elements=9, n_clusters=3, random_model=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; c2 = clugen.make_random_clustering(n_elements=9, n_clusters=3, random_model=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.sample_expected_sim(c1, c2, measure=&#39;jaccard_index&#39;, random_model=&#39;all&#39;, n_samples=50))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.sample_expected_sim(c1, c2, measure=&#39;jaccard_index&#39;, random_model=&#39;all1&#39;, n_samples=50))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.sample_expected_sim(c1, c2, measure=&#39;jaccard_index&#39;, random_model=&#39;num&#39;, n_samples=50))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.sample_expected_sim(c1, c2, measure=&#39;jaccard_index&#39;, random_model=&#39;num1&#39;, n_samples=50))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.sample_expected_sim(c1, c2, measure=&#39;jaccard_index&#39;, random_model=&#39;perm&#39;, n_samples=50))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.sample_expected_sim(c1, c2, measure=&#39;jaccard_index&#39;, random_model=&#39;perm1&#39;, n_samples=50) )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># draw n_samples random samples from the random model</span>
    <span class="n">random_clustering1_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span>
        <span class="n">n_elements</span><span class="o">=</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span>
        <span class="n">clu_size_seq</span><span class="o">=</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="n">random_model</span><span class="p">,</span>
        <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-15</span><span class="p">)</span> <span class="k">for</span> <span class="n">isample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)]</span>

    <span class="k">if</span> <span class="s1">&#39;1&#39;</span> <span class="ow">in</span> <span class="n">random_model</span><span class="p">:</span>
        <span class="c1"># this is a one-sided model so only compare to the reference clustering</span>
        <span class="n">random_clustering2_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">clustering2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># a two-sided model, so draw another n_samples from the random model</span>
        <span class="n">random_clustering2_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">clugen</span><span class="o">.</span><span class="n">make_random_clustering</span><span class="p">(</span>
            <span class="n">n_elements</span><span class="o">=</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_elements</span><span class="p">,</span>
            <span class="n">n_clusters</span><span class="o">=</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span>
            <span class="n">clu_size_seq</span><span class="o">=</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="n">random_model</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-15</span><span class="p">)</span> <span class="k">for</span> <span class="n">isample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)]</span>

    <span class="n">pairwise_comparisons</span> <span class="o">=</span> <span class="p">[</span><span class="nb">eval</span><span class="p">(</span><span class="n">measure</span> <span class="o">+</span> <span class="s1">&#39;(c1, c2)&#39;</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span>
                            <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">random_clustering1_list</span><span class="p">,</span>
                                                 <span class="n">random_clustering2_list</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">keep_samples</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pairwise_comparisons</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pairwise_comparisons</span><span class="p">)</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">These are the Information Theoretic Measures</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="mi"><a class="viewcode-back" href="../../clusim.html#clusim.sim.mi">[docs]</a><span class="k">def</span> <span class="nf">mi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Mutual Information (MI)</span>
<span class="sd">    between two clusterings :cite:`Danon2005comparingcomm`.</span>

<span class="sd">    MI = (S(c1) + S(c2) - S(c1, c2))</span>

<span class="sd">    where S(c1) is the Shannon Entropy of the clustering size distribution,</span>
<span class="sd">    S(c1, c2) is the Shannon Entropy of the join clustering size distribution,</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Mutual Information (between 0.0 and inf)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.mi(clustering1, clustering2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nmi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="nmi"><a class="viewcode-back" href="../../clusim.html#clusim.sim.nmi">[docs]</a><span class="k">def</span> <span class="nf">nmi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Normalized Mutual Information (NMI)</span>
<span class="sd">    between two clusterings :cite:`Danon2005comparingcomm`.</span>

<span class="sd">    NMI = (S(c1) + S(c2) - S(c1, c2)) / norm(c1, c2)</span>

<span class="sd">    where S(c1) is the Shannon Entropy of the clustering size distribution,</span>
<span class="sd">    S(c1, c2) is the Shannon Entropy of the join clustering size distribution,</span>
<span class="sd">    and norm(c1,c2) is a normalization term.</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :param str norm_type: &#39;sum&#39; (default), &#39;max&#39;, &#39;min&#39;, &#39;sqrt&#39;, &#39;none&#39;</span>
<span class="sd">        The normalization type:</span>
<span class="sd">        &#39;sum&#39; uses the average of the two clustering entropies,</span>
<span class="sd">        &#39;max&#39; uses the maximum of the two clustering entropies,</span>
<span class="sd">        &#39;min&#39; uses the minimum of the two clustering entropies,</span>
<span class="sd">        &#39;sqrt&#39; uses the geometric mean of the two clustering entropies,</span>
<span class="sd">        &#39;none&#39; returns the Mutual Information without a normalization</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Normalized Mutual Information index (between 0.0 and inf)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.nmi(clustering1, clustering2, norm_type=&#39;sum&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.nmi(clustering1, clustering2, norm_type=&#39;max&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.nmi(clustering1, clustering2, norm_type=&#39;min&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.nmi(clustering1, clustering2, norm_type=&#39;sqrt&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cont_tbl</span> <span class="o">=</span> <span class="n">contingency_table</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span>
                 <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span>
                 <span class="n">clustering2</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>

    <span class="n">e12</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e1</span><span class="o">*</span><span class="n">e2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">-</span> <span class="n">e12</span><span class="p">)</span> <span class="o">/</span> <span class="n">normterm</span></div>


<div class="viewcode-block" id="expected_mi"><a class="viewcode-back" href="../../clusim.html#clusim.sim.expected_mi">[docs]</a><span class="k">def</span> <span class="nf">expected_mi</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">n_clusters1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_clusters2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">clu_size_seq1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">clu_size_seq2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logbase</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;num&#39;</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the expectation of the Mutual Information between all</span>
<span class="sd">    pairs of clusterings drawn from one of six random models.</span>

<span class="sd">    See :cite:`Gates2017impact` for a detailed derivation and explanation of the different</span>
<span class="sd">    random models.</span>

<span class="sd">    .. note:: Clustering 2 is considered the gold-standard clustering for one-sided expectations</span>

<span class="sd">    :param int n_elements:</span>
<span class="sd">        The number of elements</span>

<span class="sd">    :param int n_clusters1: optional</span>
<span class="sd">        The number of clusters in the first clustering</span>

<span class="sd">    :param int n_clusters2: optional</span>
<span class="sd">        The number of clusters in the second clustering, considered the</span>
<span class="sd">        gold-standard clustering for the one-sided expectations</span>

<span class="sd">    :param list clu_size_seq1: optional</span>
<span class="sd">        The cluster size sequence of the first clustering as a list of ints.</span>

<span class="sd">    :param list clu_size_seq2: optional</span>
<span class="sd">        The cluster size sequence of the second clustering as a list of ints.</span>

<span class="sd">    :param str random_model:</span>
<span class="sd">        The random model to use:</span>

<span class="sd">        &#39;all&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements</span>

<span class="sd">        &#39;all1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements</span>

<span class="sd">        &#39;num&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">                n_elements in n_clusters</span>

<span class="sd">        &#39;num1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">                 of all clusterings of n_elements in n_clusters</span>

<span class="sd">        &#39;perm&#39; : the permutation model for a fixed cluster size sequence</span>

<span class="sd">        &#39;perm1&#39; : one-sided selection from the permutation model for a fixed</span>
<span class="sd">                  cluster size sequence, same as &#39;perm&#39;</span>

<span class="sd">    :param float logbase: (default) 2</span>
<span class="sd">        The base of all logarithms (recommended to use 2 for bits).</span>

<span class="sd">    :returns:</span>
<span class="sd">        The expected MI (between 0.0 and inf)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_mi(n_elements=5, random_model=&#39;all&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_mi(n_elements=5, random_model=&#39;all1&#39;,</span>
<span class="sd">                                         clu_size_seq2=[1,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_mi(n_elements=5, , random_model=&#39;num&#39;,</span>
<span class="sd">                                         n_clusters1=2, n_clusters2=3))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_mi(n_elements=5, random_model=&#39;num1&#39;,</span>
<span class="sd">                                         n_clusters1=2, clu_size_seq2=[1,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_mi(n_elements=5, random_model=&#39;perm&#39;,</span>
<span class="sd">                                         clu_size_seq1=[2,3],</span>
<span class="sd">                                         clu_size_seq2=[1,1,3]))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.expected_mi(n_elements=5, random_model=&#39;perm1&#39;,</span>
<span class="sd">                                         clu_size_seq1=[2,3],</span>
<span class="sd">                                         clu_size_seq2=[1,1,3]))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_elements</span><span class="p">)</span>

    <span class="n">expected_H1_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">expected_H2_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">expected_H12_sum</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">symmetric_sum</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># find the counts for clustering 1</span>
    <span class="k">if</span> <span class="s1">&#39;perm&#39;</span> <span class="ow">in</span> <span class="n">random_model</span><span class="p">:</span>
        <span class="n">counter1</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">clu_size_seq1</span><span class="p">)</span>
        <span class="n">cluster_size_range1</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">clu_size_seq1</span><span class="p">))</span>
        <span class="n">cluster_counts1</span> <span class="o">=</span> <span class="p">[</span><span class="n">counter1</span><span class="p">[</span><span class="n">clu</span><span class="p">]</span> <span class="k">for</span> <span class="n">clu</span> <span class="ow">in</span> <span class="n">cluster_size_range1</span><span class="p">]</span>

    <span class="k">elif</span> <span class="s1">&#39;num&#39;</span> <span class="ow">in</span> <span class="n">random_model</span><span class="p">:</span>
        <span class="n">sn1</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">n_clusters1</span><span class="p">)</span>
        <span class="n">cluster_size_range1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_elements</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_clusters1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">cluster_counts1</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span> <span class="o">*</span>
                           <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">-</span> <span class="n">ai</span><span class="p">,</span> <span class="n">n_clusters1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
                           <span class="n">sn1</span>
                           <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">cluster_size_range1</span><span class="p">]</span>

    <span class="k">elif</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">random_model</span><span class="p">:</span>
        <span class="n">bn</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">bell</span><span class="p">(</span><span class="n">n_elements</span><span class="p">)</span>
        <span class="n">cluster_size_range1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cluster_counts1</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span> <span class="o">*</span>
                           <span class="n">mpmath</span><span class="o">.</span><span class="n">bell</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">-</span> <span class="n">ai</span><span class="p">)</span> <span class="o">/</span> <span class="n">bn</span>
                           <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># find the counts for clustering 2</span>
    <span class="k">if</span> <span class="n">random_model</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;perm&#39;</span><span class="p">,</span> <span class="s1">&#39;perm1&#39;</span><span class="p">,</span> <span class="s1">&#39;num1&#39;</span><span class="p">,</span> <span class="s1">&#39;all1&#39;</span><span class="p">]:</span>
        <span class="n">counter2</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">clu_size_seq2</span><span class="p">)</span>
        <span class="n">cluster_size_range2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">clu_size_seq2</span><span class="p">))</span>
        <span class="n">cluster_counts2</span> <span class="o">=</span> <span class="p">[</span><span class="n">counter2</span><span class="p">[</span><span class="n">clu</span><span class="p">]</span> <span class="k">for</span> <span class="n">clu</span> <span class="ow">in</span> <span class="n">cluster_size_range2</span><span class="p">]</span>
        <span class="n">symmetric_sum</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">jclus</span><span class="p">,</span> <span class="n">clu_size2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_size_range2</span><span class="p">):</span>
            <span class="n">expected_H2_sum</span> <span class="o">+=</span> <span class="n">clu_size2</span> <span class="o">/</span> <span class="n">nf</span> <span class="o">*</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clu_size2</span><span class="o">/</span><span class="n">nf</span><span class="p">)</span> <span class="o">*</span>\
                               <span class="n">cluster_counts2</span><span class="p">[</span><span class="n">jclus</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;num&#39;</span> <span class="ow">and</span> <span class="n">n_clusters1</span> <span class="o">!=</span> <span class="n">n_clusters2</span><span class="p">:</span>
        <span class="n">sn2</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">n_clusters2</span><span class="p">)</span>
        <span class="n">cluster_size_range2</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_elements</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_clusters2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">cluster_counts2</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">bj</span><span class="p">)</span> <span class="o">*</span>
                           <span class="n">mpmath</span><span class="o">.</span><span class="n">stirling2</span><span class="p">(</span><span class="n">n_elements</span> <span class="o">-</span> <span class="n">bj</span><span class="p">,</span> <span class="n">n_clusters2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
                           <span class="n">sn2</span>
                           <span class="k">for</span> <span class="n">bj</span> <span class="ow">in</span> <span class="n">cluster_size_range2</span><span class="p">]</span>
        <span class="n">symmetric_sum</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">jclus</span><span class="p">,</span> <span class="n">clu_size2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_size_range2</span><span class="p">):</span>
            <span class="n">expected_H2_sum</span> <span class="o">+=</span> <span class="n">clu_size2</span> <span class="o">/</span> <span class="n">nf</span> <span class="o">*</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clu_size2</span><span class="o">/</span><span class="n">nf</span><span class="p">)</span> <span class="o">*</span>\
                               <span class="n">cluster_counts2</span><span class="p">[</span><span class="n">jclus</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">cluster_size_range2</span> <span class="o">=</span> <span class="n">cluster_size_range1</span>
        <span class="n">cluster_counts2</span> <span class="o">=</span> <span class="n">cluster_counts1</span>

    <span class="k">if</span> <span class="n">symmetric_sum</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">iclus</span><span class="p">,</span> <span class="n">clu_size1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_size_range1</span><span class="p">):</span>
            <span class="n">expected_H1_sum</span> <span class="o">+=</span> <span class="n">clu_size1</span> <span class="o">/</span> <span class="n">nf</span> <span class="o">*</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clu_size1</span><span class="o">/</span><span class="n">nf</span><span class="p">)</span> <span class="o">*</span>\
                               <span class="n">cluster_counts1</span><span class="p">[</span><span class="n">iclus</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">jclus</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iclus</span><span class="p">):</span>
                <span class="n">clu_size2</span> <span class="o">=</span> <span class="n">cluster_size_range1</span><span class="p">[</span><span class="n">jclus</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">nij</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">clu_size1</span> <span class="o">+</span> <span class="n">clu_size2</span> <span class="o">-</span> <span class="n">n_elements</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                 <span class="n">clu_size2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">expected_H12_sum</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cluster_counts1</span><span class="p">[</span><span class="n">iclus</span><span class="p">]</span> <span class="o">*</span>\
                        <span class="n">cluster_counts2</span><span class="p">[</span><span class="n">jclus</span><span class="p">]</span> <span class="o">*</span>\
                        <span class="n">hyper</span><span class="p">(</span><span class="n">nij</span><span class="p">,</span> <span class="n">clu_size1</span><span class="p">,</span> <span class="n">clu_size2</span><span class="p">,</span> <span class="n">n_elements</span><span class="p">)</span> <span class="o">*</span>\
                        <span class="n">nij</span><span class="o">/</span><span class="n">nf</span><span class="o">*</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nij</span><span class="o">/</span><span class="n">nf</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">nij</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">clu_size1</span> <span class="o">-</span> <span class="n">n_elements</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">clu_size1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">expected_H12_sum</span> <span class="o">+=</span> <span class="n">cluster_counts1</span><span class="p">[</span><span class="n">iclus</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span>\
                    <span class="n">hyper</span><span class="p">(</span><span class="n">nij</span><span class="p">,</span> <span class="n">clu_size1</span><span class="p">,</span> <span class="n">clu_size1</span><span class="p">,</span> <span class="n">n_elements</span><span class="p">)</span> <span class="o">*</span>\
                    <span class="n">nij</span><span class="o">/</span><span class="n">nf</span><span class="o">*</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nij</span><span class="o">/</span><span class="n">nf</span><span class="p">)</span>
        <span class="n">expected_H2_sum</span> <span class="o">=</span> <span class="n">expected_H1_sum</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">iclus</span><span class="p">,</span> <span class="n">clu_size1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_size_range1</span><span class="p">):</span>

            <span class="n">expected_H1_sum</span> <span class="o">+=</span> <span class="n">clu_size1</span> <span class="o">/</span> <span class="n">nf</span> <span class="o">*</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clu_size1</span><span class="o">/</span><span class="n">nf</span><span class="p">)</span> <span class="o">*</span>\
                               <span class="n">cluster_counts1</span><span class="p">[</span><span class="n">iclus</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">jclus</span><span class="p">,</span> <span class="n">clu_size2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_size_range2</span><span class="p">):</span>

                <span class="k">for</span> <span class="n">nij</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">clu_size1</span> <span class="o">+</span> <span class="n">clu_size2</span> <span class="o">-</span> <span class="n">n_elements</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                 <span class="nb">min</span><span class="p">(</span><span class="n">clu_size1</span><span class="p">,</span> <span class="n">clu_size2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">expected_H12_sum</span> <span class="o">+=</span> <span class="n">cluster_counts1</span><span class="p">[</span><span class="n">iclus</span><span class="p">]</span> <span class="o">*</span>\
                        <span class="n">cluster_counts2</span><span class="p">[</span><span class="n">jclus</span><span class="p">]</span> <span class="o">*</span>\
                        <span class="n">hyper</span><span class="p">(</span><span class="n">nij</span><span class="p">,</span> <span class="n">clu_size1</span><span class="p">,</span> <span class="n">clu_size2</span><span class="p">,</span> <span class="n">n_elements</span><span class="p">)</span> <span class="o">*</span>\
                        <span class="n">nij</span><span class="o">/</span><span class="n">nf</span><span class="o">*</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nij</span><span class="o">/</span><span class="n">nf</span><span class="p">)</span>

    <span class="n">expected_H1_sum</span> <span class="o">/=</span> <span class="o">-</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>
    <span class="n">expected_H2_sum</span> <span class="o">/=</span> <span class="o">-</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>
    <span class="n">expected_H12_sum</span> <span class="o">/=</span> <span class="o">-</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expected_H1_sum</span> <span class="o">+</span> <span class="n">expected_H2_sum</span> <span class="o">-</span> <span class="n">expected_H12_sum</span></div>


<div class="viewcode-block" id="adj_mi"><a class="viewcode-back" href="../../clusim.html#clusim.sim.adj_mi">[docs]</a><span class="k">def</span> <span class="nf">adj_mi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">random_model</span><span class="o">=</span><span class="s1">&#39;perm&#39;</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">logbase</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the adjusted Mutual Information for one of six random</span>
<span class="sd">    models.</span>

<span class="sd">    See :cite:`Gates2017impact` for a detailed derivation and explanation of the different</span>
<span class="sd">    random models.</span>

<span class="sd">    .. note:: Clustering 2 is considered the gold-standard clustering for one-sided expectations</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :param string random_model:</span>
<span class="sd">        The random model to use:</span>

<span class="sd">        &#39;all&#39; : uniform distribution over the set of all clusterings of n_elements</span>

<span class="sd">        &#39;all1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">            of all clusterings of n_elements</span>

<span class="sd">        &#39;num&#39; : uniform distribution over the set of all clusterings of</span>
<span class="sd">            n_elements in n_clusters</span>

<span class="sd">        &#39;num1&#39; : one-sided selection from the uniform distribution over the set</span>
<span class="sd">            of all clusterings of n_elements in n_clusters</span>

<span class="sd">        &#39;perm&#39; : the permutation model for a fixed cluster size sequence</span>

<span class="sd">        &#39;perm1&#39; : one-sided selection from the permutation model for a fixed</span>
<span class="sd">            cluster size sequence, same as &#39;perm&#39;</span>

<span class="sd">    :param str norm_type: &#39;sum&#39; (default), &#39;max&#39;, &#39;min&#39;, &#39;sqrt&#39;, &#39;none&#39;</span>
<span class="sd">        The normalization type:</span>
<span class="sd">        &#39;sum&#39; uses the average of the two clustering entropies,</span>
<span class="sd">        &#39;max&#39; uses the maximum of the two clustering entropies,</span>
<span class="sd">        &#39;min&#39; uses the minimum of the two clustering entropies,</span>
<span class="sd">        &#39;sqrt&#39; uses the geometric mean of the two clustering entropies,</span>
<span class="sd">        &#39;none&#39; returns the Mutual Information without a normalization</span>

<span class="sd">    :param float logbase: (default) 2</span>
<span class="sd">        The base of all logarithms (recommended to use 2 for bits).</span>

<span class="sd">    :returns:</span>
<span class="sd">        The adjusted Mutual Information</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,random_model=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,random_model=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adj_mi(clustering1, clustering2, random_model=&#39;all&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adj_mi(clustering1, clustering2, random_model=&#39;all1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adj_mi(clustering1, clustering2,random_model=&#39;num&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adj_mi(clustering1, clustering2,random_model=&#39;num1&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adj_mi(clustering1, clustering2,random_model=&#39;perm&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.adj_mi(clustering1, clustering2,random_model=&#39;perm1&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="n">exp_mi</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">norm_type</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">exp_mi</span> <span class="o">=</span> <span class="n">expected_mi</span><span class="p">(</span><span class="n">n_elements</span><span class="o">=</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">,</span>
                             <span class="n">n_clusters1</span><span class="o">=</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span>
                             <span class="n">n_clusters2</span><span class="o">=</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span>
                             <span class="n">clu_size_seq1</span><span class="o">=</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span>
                             <span class="n">clu_size_seq2</span><span class="o">=</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span>
                             <span class="n">random_model</span><span class="o">=</span><span class="n">random_model</span><span class="p">,</span>
                             <span class="n">logbase</span><span class="o">=</span><span class="n">logbase</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span> <span class="ow">or</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;perm1&#39;</span><span class="p">:</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span>
                     <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">logbase</span><span class="o">=</span><span class="n">logbase</span><span class="p">)</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span>
                     <span class="n">clustering2</span><span class="o">.</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">logbase</span><span class="o">=</span><span class="n">logbase</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;num&#39;</span> <span class="ow">or</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;num1&#39;</span><span class="p">:</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span> <span class="ow">or</span> <span class="n">random_model</span> <span class="o">==</span> <span class="s1">&#39;all1&#39;</span><span class="p">:</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp_mi</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span> <span class="o">-</span> <span class="n">exp_mi</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span> <span class="o">-</span> <span class="n">exp_mi</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e1</span><span class="o">*</span><span class="n">e2</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp_mi</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">nmi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp_mi</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">normterm</span><span class="p">)</span></div>


<div class="viewcode-block" id="rmi"><a class="viewcode-back" href="../../clusim.html#clusim.sim.rmi">[docs]</a><span class="k">def</span> <span class="nf">rmi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">logbase</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Reduced Mutual Information (RMI)</span>
<span class="sd">    between two clusterings :cite:`Newman2019improved`.</span>

<span class="sd">    RMI = MI(c1, c2) - log Omega(a, b) / n</span>

<span class="sd">    where MI(c1, c2) is mutual information of the clusterings c1 and c2, and</span>
<span class="sd">    where Omega(a, b) is the number of contingency tables with row and column</span>
<span class="sd">    sums equal to a and b.</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :param str norm_type: &#39;none&#39; (default)</span>
<span class="sd">        The normalization types are:</span>
<span class="sd">        &#39;none&#39; returns the RMI without a normalization.</span>
<span class="sd">        &#39;normalized&#39; returns the RMI with upper bound equals to 1.</span>

<span class="sd">    :param float logbase: (default) 2</span>
<span class="sd">        The base of all logarithms (recommended to use 2 for bits).</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Reduced Mutual Information index (between 0.0 and inf)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.rmi(clustering1, clustering2, norm_type=&#39;none&#39;))</span>
<span class="sd">    &gt;&gt;&gt; print(sim.rmi(clustering1, clustering2, norm_type=&#39;normalized&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">get_log_omega</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">logbase</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Logarithm of the number of contingency table with fixed margins.</span>

<span class="sd">        Implements an approximation by  to Diaconis and Efron :cite:</span>
<span class="sd">        `diaconis1985testing`.</span>

<span class="sd">        :param array a:</span>
<span class="sd">            Row margin of the contingency table.</span>

<span class="sd">        :param array b:</span>
<span class="sd">            Column margin of the contingency table.</span>

<span class="sd">        :param float logbase: (default) 2</span>
<span class="sd">            The base of all logarithms (recommended to use 2 for bits).</span>

<span class="sd">        :returns:</span>
<span class="sd">            The logarithm of the number of contingency tables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">R</span> <span class="o">*</span> <span class="n">S</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">R</span> <span class="o">+</span> <span class="n">w</span> <span class="o">*</span> <span class="n">a</span> <span class="o">/</span> <span class="n">n</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">S</span> <span class="o">+</span> <span class="n">w</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="n">n</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">S</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">R</span>

        <span class="n">logOmega</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">R</span> <span class="o">*</span> <span class="n">S</span><span class="p">)</span> \
            <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">nu</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> \
            <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> \
            <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">nu</span> <span class="o">*</span> <span class="n">S</span><span class="p">)</span> <span class="o">-</span>
                     <span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">+</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="o">-</span>
                     <span class="n">S</span> <span class="o">*</span> <span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">nu</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">logOmega</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>

    <span class="c1"># Compute contingency table and margins</span>
    <span class="n">cont_tbl</span> <span class="o">=</span> <span class="n">contingency_table</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>
    <span class="n">logOmega</span> <span class="o">=</span> <span class="n">get_log_omega</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">),</span>
                             <span class="n">logbase</span><span class="p">)</span>
    <span class="c1"># Compute exact MI:</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="n">I</span> <span class="o">+=</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
        <span class="n">I</span> <span class="o">-=</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
        <span class="n">I</span> <span class="o">-=</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">RMI</span> <span class="o">=</span> <span class="n">I</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span> <span class="o">-</span> <span class="n">logOmega</span>

    <span class="k">if</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;normalized&#39;</span><span class="p">:</span>
        <span class="n">normterm</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="n">normterm</span> <span class="o">-=</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="n">normterm</span> <span class="o">-=</span> <span class="n">sps</span><span class="o">.</span><span class="n">gammaln</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">logbase</span><span class="p">)</span>
        <span class="n">log_omega_aa</span> <span class="o">=</span> <span class="n">get_log_omega</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">),</span>
                                     <span class="n">logbase</span><span class="p">)</span>
        <span class="n">log_omega_bb</span> <span class="o">=</span> <span class="n">get_log_omega</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">),</span>
                                     <span class="n">logbase</span><span class="p">)</span>
        <span class="n">normterm</span> <span class="o">-=</span> <span class="p">(</span><span class="n">log_omega_aa</span> <span class="o">+</span> <span class="n">log_omega_bb</span><span class="p">)</span>
        <span class="n">normterm</span> <span class="o">/=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">RMI</span> <span class="o">/</span> <span class="n">normterm</span></div>


<div class="viewcode-block" id="vi"><a class="viewcode-back" href="../../clusim.html#clusim.sim.vi">[docs]</a><span class="k">def</span> <span class="nf">vi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">,</span> <span class="n">norm_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the Variation of Information (VI)</span>
<span class="sd">    between two clusterings :cite:`Meila2003comparingvi`.</span>

<span class="sd">    VI is technically a distance measure and can assume values in the range</span>
<span class="sd">    [0, inf), where 0 denotes identical clusterings.</span>

<span class="sd">    VI = 2*S(c1, c2) - S(c1) - S(c2)</span>

<span class="sd">    where S(c1) is the Shannon Entropy of the clustering size distribution, and</span>
<span class="sd">    S(c1, c2) is the Shannon Entropy of the join clustering size distribution.</span>

<span class="sd">    The VI can be transformed into a clustering similarity measure via the appropriate normalization.</span>

<span class="sd">    VI_{sim} = 1 - 0.5*((S(c1,c2) - S(c1))/S(c2) + (S(c1,c2) - S(c2))/S(c1))</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    norm_type : &#39;none&#39; (default) or &#39;entropy&#39;</span>
<span class="sd">        The normalization type.  &#39;none&#39; returns the standard VI as a distance metric,</span>
<span class="sd">        &#39;entropy&#39; retuns the normalized VI as a similarity measure</span>

<span class="sd">    :returns:</span>
<span class="sd">        The Variation of Information index (between 0.0 and inf)</span>

<span class="sd">    &gt;&gt;&gt; import clusim.clugen as clugen</span>
<span class="sd">    &gt;&gt;&gt; import clusim.sim as sim</span>
<span class="sd">    &gt;&gt;&gt; clustering1 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clustering2 = clugen.make_random_clustering(n_elements=9, n_clusters=3,</span>
<span class="sd">                                                    random_model=&#39;num&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(sim.vi(clustering1, clustering2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cont_tbl</span> <span class="o">=</span> <span class="n">contingency_table</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span>
                 <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span>
                 <span class="n">clustering2</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>

    <span class="n">e12</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">norm_type</span> <span class="o">==</span> <span class="s1">&#39;entropy&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">e12</span> <span class="o">-</span> <span class="n">e1</span><span class="p">)</span><span class="o">/</span><span class="n">e2</span> <span class="o">+</span> <span class="p">(</span><span class="n">e12</span> <span class="o">-</span> <span class="n">e2</span><span class="p">)</span><span class="o">/</span><span class="n">e1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e12</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">-</span> <span class="n">e2</span></div>



<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">These are for overlapping clusterings</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="geometric_accuracy"><a class="viewcode-back" href="../../clusim.html#clusim.sim.geometric_accuracy">[docs]</a><span class="k">def</span> <span class="nf">geometric_accuracy</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function calculates the geometric accuracy between two (overlapping) clusterings.</span>

<span class="sd">    See :cite:`Nepusz2012overlapprotein` for a detailed derivation and explanation of the measure.</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns: the geometric accuracy</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">cont_tbl</span> <span class="o">=</span> <span class="n">contingency_table</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="n">Nclusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">)</span>
    <span class="n">Mclusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">)</span>

    <span class="n">Sn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">Nclusters</span><span class="p">)</span>

    <span class="n">PPV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">Mclusters</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Sn</span> <span class="o">*</span> <span class="n">PPV</span><span class="p">)</span></div>


<div class="viewcode-block" id="overlap_quality"><a class="viewcode-back" href="../../clusim.html#clusim.sim.overlap_quality">[docs]</a><span class="k">def</span> <span class="nf">overlap_quality</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function calculates the overlap quality between two (overlapping) clusterings.</span>

<span class="sd">    See :cite:`Ahn2010link` for a detailed derivation and explanation of the measure.</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns: the overlap quality</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">!=</span> <span class="n">clustering2</span><span class="o">.</span><span class="n">n_elements</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ClusteringSimilarityError</span>

    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">e1</span> <span class="o">!=</span> <span class="n">e2</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">clustering2</span><span class="o">.</span><span class="n">elements</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ClusteringSimilarityError</span>

    <span class="n">num_memberships1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">elm2clu_dict</span><span class="p">[</span><span class="n">el</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>
    <span class="n">num_memberships2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">elm2clu_dict</span><span class="p">[</span><span class="n">el</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">clustering2</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>

    <span class="n">overlap_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="n">num_memberships1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="nb">max</span><span class="p">(</span><span class="n">num_memberships2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i_el</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">):</span>
        <span class="n">overlap_dist</span><span class="p">[</span><span class="n">num_memberships1</span><span class="p">[</span><span class="n">i_el</span><span class="p">],</span> <span class="n">num_memberships2</span><span class="p">[</span><span class="n">i_el</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">overlap_dist</span> <span class="o">=</span> <span class="n">overlap_dist</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">overlap_dist</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">overlap_dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">+</span>\
        <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">overlap_dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span>\
        <span class="n">entropy</span><span class="p">(</span><span class="n">overlap_dist</span><span class="p">)</span></div>


<div class="viewcode-block" id="onmi"><a class="viewcode-back" href="../../clusim.html#clusim.sim.onmi">[docs]</a><span class="k">def</span> <span class="nf">onmi</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function calculates the overlapping normalized mutual information.</span>

<span class="sd">    See :cite:`Lancichinetti2009onmi` for a detailed derivation and explanation of the measure.</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns: the overlapping normalized mutual information</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">cont_tbl</span> <span class="o">=</span> <span class="n">contingency_table</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">)</span>

    <span class="c1"># e12 never used.</span>
    <span class="n">e12</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>

    <span class="n">prob_clu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span>\
        <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span>
    <span class="n">prob_clu2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">clu_size_seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span>\
        <span class="n">clustering2</span><span class="o">.</span><span class="n">n_elements</span>
    <span class="n">joint_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cont_tbl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span>

    <span class="n">entropy_rv1</span> <span class="o">=</span> <span class="n">binary_entropy</span><span class="p">(</span><span class="n">prob_clu1</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">-</span><span class="n">prob_clu1</span><span class="p">)</span>
    <span class="n">entropy_rv2</span> <span class="o">=</span> <span class="n">binary_entropy</span><span class="p">(</span><span class="n">prob_clu2</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">-</span><span class="n">prob_clu2</span><span class="p">)</span>

    <span class="n">entropy_rv12_pure</span> <span class="o">=</span> <span class="n">binary_entropy</span><span class="p">(</span><span class="n">joint_prob</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">-</span><span class="n">joint_prob</span><span class="p">)</span>

    <span class="n">entropy_rv12_mixing</span> <span class="o">=</span> <span class="n">binary_entropy</span><span class="p">(</span>
        <span class="n">prob_clu1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">joint_prob</span><span class="p">,</span>
        <span class="n">prob_clu2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span> <span class="o">-</span> <span class="n">joint_prob</span><span class="p">)</span>

    <span class="n">minimize_conditions_rv12</span> <span class="o">=</span> <span class="n">entropy_rv12_pure</span> <span class="o">&gt;</span> <span class="n">entropy_rv12_mixing</span>

    <span class="n">e_r2_cond_r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">entropy_rv12_pure</span> <span class="o">+</span> <span class="n">entropy_rv12_mixing</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">entropy_rv1</span>

    <span class="n">e_r2_cond_Boldr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering2</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">minimize_conditions_rv12</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">k2</span><span class="p">]):</span>
            <span class="n">e_r2_cond_Boldr1</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_r2_cond_r1</span><span class="p">[</span>
                <span class="n">k2</span><span class="p">,</span> <span class="n">minimize_conditions_rv12</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">k2</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">entropy_rv2</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e_r2_cond_Boldr1</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="n">e_r1_cond_r2</span> <span class="o">=</span> <span class="p">(</span><span class="n">entropy_rv12_pure</span> <span class="o">+</span> <span class="n">entropy_rv12_mixing</span><span class="p">)</span> <span class="o">-</span> <span class="n">entropy_rv2</span>

    <span class="n">e_r1_cond_Boldr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">minimize_conditions_rv12</span><span class="p">[</span><span class="n">k1</span><span class="p">]):</span>
            <span class="n">e_r1_cond_Boldr2</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_r1_cond_r2</span><span class="p">[</span>
                <span class="n">k1</span><span class="p">,</span> <span class="n">minimize_conditions_rv12</span><span class="p">[</span><span class="n">k1</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">entropy_rv1</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e_r1_cond_Boldr2</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">e_r1_cond_Boldr2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">e_r2_cond_Boldr1</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">make_overlapping_membership_matrix</span><span class="p">(</span><span class="n">clustering</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct matrix of mapping nodes to clusterings.&quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">clustering</span><span class="o">.</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">clustering</span><span class="o">.</span><span class="n">n_elements</span><span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">clu</span> <span class="ow">in</span> <span class="n">clustering</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">clustering</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>
        <span class="n">v</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">clustering</span><span class="o">.</span><span class="n">clu2elm_dict</span><span class="p">[</span><span class="n">clu</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">+=</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">v</span>
    <span class="k">return</span> <span class="n">A</span>


<div class="viewcode-block" id="omega_index"><a class="viewcode-back" href="../../clusim.html#clusim.sim.omega_index">[docs]</a><span class="k">def</span> <span class="nf">omega_index</span><span class="p">(</span><span class="n">clustering1</span><span class="p">,</span> <span class="n">clustering2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function calculates the omega index between two clusterings.</span>

<span class="sd">    See :cite:`Collins1988omega` for a detailed derivation and explanation of the measure.</span>

<span class="sd">    :param Clustering clustering1:</span>
<span class="sd">        The first clustering.</span>

<span class="sd">    :param Clustering clustering2:</span>
<span class="sd">        The second clustering.</span>

<span class="sd">    :returns: the omega index</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">!=</span> <span class="n">clustering2</span><span class="o">.</span><span class="n">n_elements</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ClusteringSimilarityError</span>

    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">e1</span> <span class="o">!=</span> <span class="n">e2</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">clustering2</span><span class="o">.</span><span class="n">elements</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ClusteringSimilarityError</span>

    <span class="n">A1</span> <span class="o">=</span> <span class="n">make_overlapping_membership_matrix</span><span class="p">(</span><span class="n">clustering1</span><span class="p">)</span>
    <span class="n">A2</span> <span class="o">=</span> <span class="n">make_overlapping_membership_matrix</span><span class="p">(</span><span class="n">clustering2</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">*</span> <span class="p">(</span><span class="n">clustering1</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="n">maxNover</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">A1</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()),</span> <span class="nb">max</span><span class="p">(</span><span class="n">A2</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">Anot</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">triu</span><span class="p">((</span><span class="n">A1</span> <span class="o">!=</span> <span class="n">A2</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">omega_u</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">Anot</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">M</span>

    <span class="n">t_0_1</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">triu</span><span class="p">((</span><span class="n">A1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">t_0_2</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">triu</span><span class="p">((</span><span class="n">A2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">t_k_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">spsparse</span><span class="o">.</span><span class="n">triu</span><span class="p">((</span><span class="n">A1</span> <span class="o">==</span> <span class="n">i</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxNover</span><span class="p">)]</span>
    <span class="n">t_k_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">spsparse</span><span class="o">.</span><span class="n">triu</span><span class="p">((</span><span class="n">A2</span> <span class="o">==</span> <span class="n">i</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxNover</span><span class="p">)]</span>

    <span class="n">omega_e</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_0_1</span><span class="o">*</span><span class="n">t_0_2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t_k_1</span><span class="p">,</span> <span class="n">t_k_2</span><span class="p">))</span> <span class="o">/</span> <span class="n">M</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">omega_u</span> <span class="o">-</span> <span class="n">omega_e</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">omega_e</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../clusim.html">clusim 0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Alexander Gates and Yong-Yeol Ahn.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.3.
    </div>
  </body>
</html>